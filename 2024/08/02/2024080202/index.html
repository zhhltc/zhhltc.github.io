<!DOCTYPE html>
<html lang='zh-CN'>

<head>
  <meta name="generator" content="Hexo 5.4.0">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.19.0">
  <meta charset="utf-8">
  

  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://gcore.jsdelivr.net'>
  <link rel="preconnect" href="https://gcore.jsdelivr.net" crossorigin>
  <link rel='dns-prefetch' href='//unpkg.com'>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  
  <title>Java 中常用的 23 种设计模式详解2 - 苏三博客</title>

  
    <meta name="description" content="Java 中常用的 23 种设计模式详解">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 中常用的 23 种设计模式详解2">
<meta property="og:url" content="https://su3.cn/2024/08/02/2024080202/index.html">
<meta property="og:site_name" content="苏三博客">
<meta property="og:description" content="Java 中常用的 23 种设计模式详解">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://su3.cn/postimg/v2-1d38c56fcb3eff75f9cbc5d16b4b457e_r.jpg">
<meta property="og:image" content="https://su3.cn/postimg/v2-93b066eaa9bbe5dd70e66f6877c5dba3_r.jpg">
<meta property="article:published_time" content="2024-08-02T10:00:00.000Z">
<meta property="article:modified_time" content="2025-12-16T09:08:08.836Z">
<meta property="article:author" content="SuSan">
<meta property="article:tag" content="笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://su3.cn/postimg/v2-1d38c56fcb3eff75f9cbc5d16b4b457e_r.jpg">
  
  
  
  <meta name="keywords" content="笔记">

  <!-- feed -->
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  

  

  


  
    
      <link href="https://gcore.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@1.1.0/lxgwwenkaiscreen.css" rel="stylesheet">
    
  
</head>

<body>
  




  <div class='l_body' id='start'>
    <aside class='l_left' layout='post'>
    

  

<header class="header"><div class="logo-wrap"><a class="avatar"  style="width:52px;height:52px;" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="/pic.jpg" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/image/2659360.svg';"></a><a class="title" href="/"><div class="main" ff="title" style="font-size: 1.12rem;">苏三博客</div><div class="sub cap" style="margin-top:3px;font-size:10px;color:#CD853F;">- Su3.cn 无限制,有些线路较慢</div><div class="sub cap" style="margin-top:3px;font-size:10px;color:green;">- Xen.cc 静态资源托管加速,限流</div></a></div>

<nav class="menu dis-select"><a class="nav-item active" href="/">博客</a><a class="nav-item" href="/utils/">工具</a><a class="nav-item" href="/music/">歌单</a><a class="nav-item" href="/about/">更多</a></nav>
</header>


<div class="widgets">

<widget class="widget-wrapper toc single" id="data-toc"><div class="widget-header cap dis-select"><span class="name">Java 中常用的 23 种设计模式详解2</span></div><div class="widget-body fs14"><div class="doc-tree active"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">设计模式的分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A6%81%E7%B4%A0"><span class="toc-text">设计模式的基本要素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%A7%88"><span class="toc-text">种设计模式概览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E4%BB%93%E5%BA%93%E5%9C%B0%E5%9D%80"><span class="toc-text">设计模式代码示例仓库地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3"><span class="toc-text">设计模式详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%EF%BC%88Factory-Method%EF%BC%89"><span class="toc-text">1. 工厂方法模式（Factory Method）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%88Abstract-Factory%EF%BC%89"><span class="toc-text">2. 抽象工厂模式（Abstract Factory）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88Builder%EF%BC%89"><span class="toc-text">3. 建造者模式（Builder）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%88Prototype%EF%BC%89"><span class="toc-text">4. 原型模式（Prototype）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88Singleton%EF%BC%89"><span class="toc-text">5. 单例模式（Singleton）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88Adapter%EF%BC%89"><span class="toc-text">6. 适配器模式（Adapter）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%EF%BC%88Bridge%EF%BC%89"><span class="toc-text">7. 桥接模式（Bridge）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%EF%BC%88Composite%EF%BC%89"><span class="toc-text">8. 组合模式（Composite）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%EF%BC%88Decorator%EF%BC%89"><span class="toc-text">9. 装饰模式（Decorator）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%EF%BC%88Facade%EF%BC%89"><span class="toc-text">10. 外观模式（Facade）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%EF%BC%88Flyweight%EF%BC%89"><span class="toc-text">11. 享元模式（Flyweight）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%EF%BC%88Proxy%EF%BC%89"><span class="toc-text">12. 代理模式（Proxy）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88Interpreter%EF%BC%89"><span class="toc-text">13. 解释器模式（Interpreter）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%EF%BC%88Template-Method%EF%BC%89"><span class="toc-text">14. 模板方法模式（Template Method）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%EF%BC%88Chain-of-Responsibility%EF%BC%89"><span class="toc-text">15. 责任链模式（Chain of Responsibility）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%EF%BC%88Command%EF%BC%89"><span class="toc-text">16. 命令模式（Command）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88Iterator%EF%BC%89"><span class="toc-text">17. 迭代器模式（Iterator）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88Mediator%EF%BC%89"><span class="toc-text">18. 中介者模式（Mediator）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%EF%BC%88Memento%EF%BC%89"><span class="toc-text">19. 备忘录模式（Memento）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88Observer%EF%BC%89"><span class="toc-text">20. 观察者模式（Observer）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%EF%BC%88State%EF%BC%89"><span class="toc-text">21. 状态模式（State）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%EF%BC%88Strategy%EF%BC%89"><span class="toc-text">22. 策略模式（Strategy）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88Visitor%EF%BC%89"><span class="toc-text">23. 访问者模式（Visitor）</span></a></li></ol></li></ol></div></div></widget>




</div>


    </aside>
    <div class='l_main'>
      

      



<div class="bread-nav fs12"><div id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a><span class="sep"></span><a class="cap breadcrumb" href="/">文章</a><span class="sep"></span><a class="cap breadcrumb-link" href="/categories/Java/">Java</a></div><div id="post-meta">发布于&nbsp;<time datetime="2024-08-02T10:00:00.000Z">2024-08-02</time></div></div>

<article class='md-text content post'>
<h1 class="article-title"><span>Java 中常用的 23 种设计模式详解2</span></h1>
<hr>
<p>设计模式是在软件设计中反复出现的问题的通用解决方案。它们是经过多次验证和应用的指导原则，旨在帮助软件开发人员解决特定类型的问题，提高代码的可维护性、可扩展性和重用性。</p>
<p>设计模式是一种抽象化的思维方式，可以帮助开发人员更好地组织和设计他们的代码。它们提供了一种通用的框架，可以用于解决各种不同的软件设计问题。设计模式不是完整的代码，而是一种描述问题和解决方案之间关系的模板。</p>
<p>设计模式并不是一成不变的法则，而是根据不同的问题和情境来决定是否使用以及如何使用。了解和应用设计模式可以帮助开发人员更好地组织代码，提高代码的可读性和可维护性，同时也有助于促进团队之间的合作和沟通。</p>
<h2 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h2><ol>
<li> <strong>创建型模式（Creational）</strong>：关注对象的实例化过程，包括了如何实例化对象、隐藏对象的创建细节等。常见的创建型模式有单例模式、工厂模式、抽象工厂模式等。</li>
<li> <strong>结构型模式（Structural）</strong>：关注对象之间的组合方式，以达到构建更大结构的目标。这些模式帮助你定义对象之间的关系，从而实现更大的结构。常见的结构型模式有适配器模式、装饰器模式、代理模式等。</li>
<li> <strong>行为型模式（Behavioral）</strong>：关注对象之间的通信方式，以及如何合作共同完成任务。这些模式涉及到对象之间的交互、责任分配等。常见的行为型模式有观察者模式、策略模式、命令模式等。</li>
</ol>
<h2 id="设计模式的基本要素"><a href="#设计模式的基本要素" class="headerlink" title="设计模式的基本要素"></a>设计模式的基本要素</h2><ol>
<li> <strong>模式名称</strong>：每个设计模式都有一个简洁的名称，用于描述问题、解决方案和效果。这个名称有助于在交流中快速指代模式。</li>
<li> <strong>问题</strong>：描述了在什么情况下应该考虑使用特定的设计模式。问题部分阐述了该模式试图解决的具体设计难题。</li>
<li> <strong>解决方案</strong>：解决方案部分提供了一个详细的设计指南，描述了如何组织类、对象以及它们之间的关系，以解决特定问题。这包括了每个角色的职责、协作方式等。</li>
<li> <strong>效果</strong>：描述了模式应用的效果及使用模式应权衡的问题。</li>
</ol>
<h2 id="种设计模式概览"><a href="#种设计模式概览" class="headerlink" title="种设计模式概览"></a>种设计模式概览</h2><div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://su3.cn/postimg/v2-1d38c56fcb3eff75f9cbc5d16b4b457e_r.jpg" fancybox="true"/></div></div>

<p><strong>设计模式间的关系</strong>  </p>
<hr>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://su3.cn/postimg/v2-93b066eaa9bbe5dd70e66f6877c5dba3_r.jpg" fancybox="true"/></div></div>

<h2 id="设计模式代码示例仓库地址"><a href="#设计模式代码示例仓库地址" class="headerlink" title="设计模式代码示例仓库地址"></a>设计模式代码示例仓库地址</h2><p><a href="https://link.zhihu.com/?target=https://gitee.com/zhuzaizhu/23-design-pattern">23 种设计模式 JAVA 实现</a></p>
<h2 id="设计模式详解"><a href="#设计模式详解" class="headerlink" title="设计模式详解"></a>设计模式详解</h2><h3 id="1-工厂方法模式（Factory-Method）"><a href="#1-工厂方法模式（Factory-Method）" class="headerlink" title="1. 工厂方法模式（Factory Method）"></a>1. 工厂方法模式（Factory Method）</h3><p><strong>问题</strong>：</p>
<p>在软件设计中，我们经常遇到需要创建不同类型对象的情况。但是，如果直接在代码中实例化对象，会使代码紧密耦合在一起，难以维护和扩展。此外，如果对象的创建方式需要变化，那么就需要在整个代码中进行大量的修改。工厂方法模式旨在解决这个问题。</p>
<p><strong>解决方案</strong>：</p>
<p>工厂方法模式提供了一个创建对象的接口，但是将具体的对象创建延迟到子类中。这样，客户端代码不需要知道要创建的具体对象的类，只需要通过工厂方法来创建对象。这使得客户端代码与具体对象的创建解耦，提高了代码的灵活性和可维护性。</p>
<p>在工厂方法模式中，通常会定义一个抽象工厂类，其中包含一个创建对象的抽象方法，而具体的对象创建则由具体的子类实现。这样，每个具体的子类都可以根据需要创建不同类型的对象，而客户端代码只需要通过抽象工厂类来调用工厂方法，而不需要关心具体的对象创建细节。</p>
<p><strong>效果</strong>：</p>
<p>工厂方法模式的优点包括：</p>
<ul>
<li>  <strong>松耦合</strong>：客户端代码与具体对象的创建解耦，使得系统更具弹性和可维护性。</li>
<li>  <strong>扩展性</strong>：通过添加新的具体工厂和产品子类，可以很容易地扩展系统以支持新的对象类型。</li>
<li>  <strong>封装性</strong>：将对象的创建集中在工厂类中，封装了对象的创建细节，使得客户端代码更简洁。</li>
</ul>
<p>然而，工厂方法模式也可能引入一些额外的复杂性，因为需要定义多个工厂类和产品类的层次结构。这可能会导致系统中类的数量增加。在选择使用工厂方法模式时，需要根据具体情况进行权衡。</p>
<p>工厂方法模式在实际应用中非常常见，例如，图形库可以使用工厂方法模式来创建不同类型的图形对象，数据库访问框架可以使用工厂方法模式来创建不同类型的数据库连接等。</p>
<p><strong>代码示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">// 首先，我们需要定义一个图形接口</span><br><span class="line">interface Shape &#123;</span><br><span class="line">    void draw();</span><br><span class="line">&#125;</span><br><span class="line">// 然后，我们实现两个具体的图形类，分别是 Circle（圆形）和 Rectangle（矩形）</span><br><span class="line">class Circle implements Shape &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        System.out.println(&quot;Drawing a circle&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Rectangle implements Shape &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        System.out.println(&quot;Drawing a rectangle&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 接下来，我们创建一个抽象工厂类 ShapeFactory</span><br><span class="line">// 它定义了一个抽象的工厂方法 createShape，子类将实现这个方法来创建具体的图形对象</span><br><span class="line">abstract class ShapeFactory &#123;</span><br><span class="line">    abstract Shape createShape();</span><br><span class="line">&#125;</span><br><span class="line">// 然后，我们创建两个具体的工厂类，分别是 CircleFactory 和 RectangleFactory</span><br><span class="line">// 它们分别实现了 ShapeFactory 并重写了 createShape 方法来返回相应的图形对象</span><br><span class="line">class CircleFactory extends ShapeFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    Shape createShape() &#123;</span><br><span class="line">        return new Circle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class RectangleFactory extends ShapeFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    Shape createShape() &#123;</span><br><span class="line">        return new Rectangle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 我们可以使用这些工厂类来创建图形对象</span><br><span class="line">public class FactoryMethodExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ShapeFactory circleFactory = new CircleFactory();</span><br><span class="line">        Shape circle = circleFactory.createShape();</span><br><span class="line">        circle.draw();</span><br><span class="line">        </span><br><span class="line">        ShapeFactory rectangleFactory = new RectangleFactory();</span><br><span class="line">        Shape rectangle = rectangleFactory.createShape();</span><br><span class="line">        rectangle.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-抽象工厂模式（Abstract-Factory）"><a href="#2-抽象工厂模式（Abstract-Factory）" class="headerlink" title="2. 抽象工厂模式（Abstract Factory）"></a>2. 抽象工厂模式（Abstract Factory）</h3><p><strong>问题</strong>：</p>
<p>在某些情况下，需要创建一系列相关或相互依赖的对象，这些对象属于一组相关的产品族。同时，系统需要保证这些产品族之间的一致性。如果直接在代码中创建这些对象，会使得代码与具体产品的细节紧密耦合，不利于后续的扩展和维护。</p>
<p><strong>解决方案</strong>：</p>
<p>抽象工厂模式提供了一个接口，用于创建一系列相关或相互依赖的对象。通过使用抽象工厂接口及其具体实现，可以将对象的创建与客户端代码分离，从而实现系统的松耦合。抽象工厂模式涉及多个角色：</p>
<ul>
<li>  <strong>抽象工厂（Abstract Factory）</strong>：声明了一组用于创建不同产品的抽象方法。具体的工厂类必须实现这些方法来创建具体的产品对象。</li>
<li>  <strong>具体工厂（Concrete Factory）</strong>：实现抽象工厂接口，负责创建特定种类的产品对象。</li>
<li>  <strong>抽象产品（Abstract Product）</strong>：定义了产品的通用接口，具体产品必须实现这个接口。</li>
<li>  <strong>具体产品（Concrete Product）</strong>：实现抽象产品接口，是抽象工厂创建的实际对象。</li>
</ul>
<p><strong>效果</strong>：</p>
<p>抽象工厂模式的使用可以带来以下效果：</p>
<ul>
<li>  <strong>产品族一致性</strong>：抽象工厂确保创建的产品是一组相关的产品族，保证了这些产品之间的一致性。</li>
<li>  <strong>松耦合</strong>：客户端代码不需要直接依赖于具体产品，只需要通过抽象工厂接口创建产品，从而降低了代码的耦合度。</li>
<li>  <strong>可扩展性</strong>：增加新的产品族或产品变得相对容易，只需要添加新的具体工厂和产品类即可，不需要修改现有代码。</li>
<li>  <strong>限制</strong>：抽象工厂模式要求系统中的每个产品族都必须有一个对应的具体工厂，这可能增加了系统的复杂性。</li>
</ul>
<p>抽象工厂模式适用于需要创建一系列相关产品并保证它们之间一致性的情况，例如图形界面库中的 UI 元素，不同操作系统下的界面组件等。通过使用抽象工厂模式，可以更好地管理和组织这些产品的创建过程。</p>
<p><strong>代码示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">// 抽象产品接口：操作系统</span><br><span class="line">interface OperatingSystem &#123;</span><br><span class="line">    void run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体产品：Windows操作系统</span><br><span class="line">class WindowsOS implements OperatingSystem &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;Running Windows OS&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体产品：Linux操作系统</span><br><span class="line">class LinuxOS implements OperatingSystem &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;Running Linux OS&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 抽象产品接口：应用程序</span><br><span class="line">interface Application &#123;</span><br><span class="line">    void open();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体产品：Word应用程序</span><br><span class="line">class WordApplication implements Application &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void open() &#123;</span><br><span class="line">        System.out.println(&quot;Opening Word Application&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体产品：Excel应用程序</span><br><span class="line">class ExcelApplication implements Application &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void open() &#123;</span><br><span class="line">        System.out.println(&quot;Opening Excel Application&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 抽象工厂接口</span><br><span class="line">interface SoftwareFactory &#123;</span><br><span class="line">    OperatingSystem createOperatingSystem();</span><br><span class="line">    Application createApplication();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体工厂：Windows工厂</span><br><span class="line">class WindowsFactory implements SoftwareFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public OperatingSystem createOperatingSystem() &#123;</span><br><span class="line">        return new WindowsOS();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Application createApplication() &#123;</span><br><span class="line">        return new ExcelApplication();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体工厂：Linux工厂</span><br><span class="line">class LinuxFactory implements SoftwareFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public OperatingSystem createOperatingSystem() &#123;</span><br><span class="line">        return new LinuxOS();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Application createApplication() &#123;</span><br><span class="line">        return new WordApplication();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在这个示例中，抽象工厂模式通过SoftwareFactory接口和其实现类来创建不同类型的操作系统和应用程序。</span><br><span class="line">// 客户端代码可以根据需要选择不同的工厂实例来创建不同的产品组合。</span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SoftwareFactory windowsFactory = new WindowsFactory();</span><br><span class="line">        OperatingSystem windowsOS = windowsFactory.createOperatingSystem();</span><br><span class="line">        Application windowsApp = windowsFactory.createApplication();</span><br><span class="line"></span><br><span class="line">        windowsOS.run();</span><br><span class="line">        windowsApp.open();</span><br><span class="line"></span><br><span class="line">        SoftwareFactory linuxFactory = new LinuxFactory();</span><br><span class="line">        OperatingSystem linuxOS = linuxFactory.createOperatingSystem();</span><br><span class="line">        Application linuxApp = linuxFactory.createApplication();</span><br><span class="line"></span><br><span class="line">        linuxOS.run();</span><br><span class="line">        linuxApp.open();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-建造者模式（Builder）"><a href="#3-建造者模式（Builder）" class="headerlink" title="3. 建造者模式（Builder）"></a>3. 建造者模式（Builder）</h3><p><strong>问题</strong>：</p>
<p>在某些情况下，一个对象的创建过程非常复杂，涉及多个步骤，每个步骤都可能有不同的实现方式。如果将所有创建逻辑放在一个类中，会导致该类变得庞大且难以维护。此外，如果需要创建不同的变体对象，就需要在该类中添加更多的逻辑，使得代码变得混乱。</p>
<p><strong>解决方案</strong>：</p>
<p>建造者模式提供了一种将一个复杂对象的构建过程与其表示分离的方法。它将对象的构建过程封装在一个独立的 “建造者” 类中，由该类负责逐步构建对象。这样，可以根据需要创建不同的建造者来构建不同的对象变体。通常，建造者模式涉及以下角色：</p>
<ul>
<li>  <strong>产品（Product）</strong>：表示正在构建的复杂对象。建造者模式的目标是构建这个产品。</li>
<li>  <strong>抽象建造者（Abstract Builder）</strong>：定义了构建产品的步骤和方法，但没有具体的实现。不同的具体建造者可以实现不同的构建步骤，从而创建不同的产品变体。</li>
<li>  <strong>具体建造者（Concrete Builder）</strong>：实现了抽象建造者定义的方法，完成了产品的构建过程。每个具体建造者负责构建特定的产品变体。</li>
<li>  <strong>指导者（Director）</strong>：负责控制建造的过程。它通过将客户端与具体建造者分离，确保产品的构建是按照一定顺序和规则进行的。</li>
</ul>
<p><strong>效果</strong>：</p>
<p>建造者模式的效果包括：</p>
<ul>
<li>  <strong>分离构建过程和表示</strong>：通过建造者模式，可以将复杂对象的构建过程与其最终表示分离，使得构建过程更加清晰可控。</li>
<li>  <strong>支持不同的表示</strong>：通过使用不同的具体建造者，可以创建不同的产品表示，而不改变客户端的代码。</li>
<li>  <strong>更好的可扩展性</strong>：如果需要添加新的产品变体，只需创建一个新的具体建造者即可，而无需修改已有的代码。</li>
<li>  <strong>隐藏产品的内部结构</strong>：客户端只需与抽象建造者和指导者交互，无需关心产品的内部构建细节。</li>
</ul>
<p>总之，建造者模式适用于需要构建复杂对象，且构建过程涉及多个步骤或变体的情况。通过将构建过程分解为可重用的步骤，建造者模式提供了一种结构化的方法来创建对象。</p>
<p><strong>代码示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">// 首先，我们定义房屋类 House，它具有多个属性，如地基、结构、屋顶和装修。</span><br><span class="line">class House &#123;</span><br><span class="line">    private String foundation;</span><br><span class="line">    private String structure;</span><br><span class="line">    private String roof;</span><br><span class="line">    private String interior;</span><br><span class="line"></span><br><span class="line">    public void setFoundation(String foundation) &#123;</span><br><span class="line">        this.foundation = foundation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setStructure(String structure) &#123;</span><br><span class="line">        this.structure = structure;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setRoof(String roof) &#123;</span><br><span class="line">        this.roof = roof;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setInterior(String interior) &#123;</span><br><span class="line">        this.interior = interior;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;House [foundation=&quot; + foundation + &quot;, structure=&quot; + structure + &quot;, roof=&quot; + roof + &quot;, interior=&quot; + interior + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 然后，我们创建一个抽象建造者类 HouseBuilder，它定义了构建房屋的方法。</span><br><span class="line">abstract class HouseBuilder &#123;</span><br><span class="line">    protected House house = new House();</span><br><span class="line"></span><br><span class="line">    public abstract void buildFoundation();</span><br><span class="line">    public abstract void buildStructure();</span><br><span class="line">    public abstract void buildRoof();</span><br><span class="line">    public abstract void buildInterior();</span><br><span class="line"></span><br><span class="line">    public House getHouse() &#123;</span><br><span class="line">        return house;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 接下来，我们创建两个具体的建造者类 ConcreteHouseBuilder 和 LuxuryHouseBuilder</span><br><span class="line">// 分别实现了不同类型房屋的构建过程。</span><br><span class="line">// 具体建造者类 - 普通房屋</span><br><span class="line">class ConcreteHouseBuilder extends HouseBuilder &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void buildFoundation() &#123;</span><br><span class="line">        house.setFoundation(&quot;Standard Foundation&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void buildStructure() &#123;</span><br><span class="line">        house.setStructure(&quot;Standard Structure&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void buildRoof() &#123;</span><br><span class="line">        house.setRoof(&quot;Standard Roof&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void buildInterior() &#123;</span><br><span class="line">        house.setInterior(&quot;Standard Interior&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体建造者类 - 豪华房屋</span><br><span class="line">class LuxuryHouseBuilder extends HouseBuilder &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void buildFoundation() &#123;</span><br><span class="line">        house.setFoundation(&quot;Strong Foundation&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void buildStructure() &#123;</span><br><span class="line">        house.setStructure(&quot;Reinforced Structure&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void buildRoof() &#123;</span><br><span class="line">        house.setRoof(&quot;Elegant Roof&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void buildInterior() &#123;</span><br><span class="line">        house.setInterior(&quot;Luxury Interior&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 最后，我们创建指导者类 Director，它协调建造过程并返回构建的房屋对象。</span><br><span class="line">class Director &#123;</span><br><span class="line">    private HouseBuilder builder;</span><br><span class="line"></span><br><span class="line">    public Director(HouseBuilder builder) &#123;</span><br><span class="line">        this.builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public House constructHouse() &#123;</span><br><span class="line">        builder.buildFoundation();</span><br><span class="line">        builder.buildStructure();</span><br><span class="line">        builder.buildRoof();</span><br><span class="line">        builder.buildInterior();</span><br><span class="line">        return builder.getHouse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 这个示例演示了如何使用建造者模式创建不同类型的房屋，每种房屋类型的建造过程都由相应的具体建造者类负责实现，而指导者类负责协调建造过程。</span><br><span class="line">public class BuilderPatternExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HouseBuilder concreteBuilder = new ConcreteHouseBuilder();</span><br><span class="line">        Director director1 = new Director(concreteBuilder);</span><br><span class="line">        House concreteHouse = director1.constructHouse();</span><br><span class="line">        System.out.println(&quot;Concrete House: &quot; + concreteHouse);</span><br><span class="line"></span><br><span class="line">        HouseBuilder luxuryBuilder = new LuxuryHouseBuilder();</span><br><span class="line">        Director director2 = new Director(luxuryBuilder);</span><br><span class="line">        House luxuryHouse = director2.constructHouse();</span><br><span class="line">        System.out.println(&quot;Luxury House: &quot; + luxuryHouse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-原型模式（Prototype）"><a href="#4-原型模式（Prototype）" class="headerlink" title="4. 原型模式（Prototype）"></a>4. 原型模式（Prototype）</h3><p><strong>问题</strong>：</p>
<p>在某些情况下，需要创建对象的副本，但复制一个对象的成本可能很高，或者希望避免与对象的具体类耦合。例如，当创建对象的过程较为复杂，或者对象包含大量共享的状态时，使用常规的创建方法可能会导致性能下降。</p>
<p><strong>解决方案</strong>：</p>
<p>原型模式的解决方案是通过复制现有对象来创建新对象，而不是从头开始构建。这允许我们以更高效的方式创建新对象，同时避免了与对象类的直接耦合。核心概念是在原型对象的基础上进行克隆，使得新对象具有与原型相同的初始状态。</p>
<p>在原型模式中，通常会有以下几个角色：</p>
<ul>
<li>  <strong>抽象原型（Prototype）</strong>：声明克隆方法，作为所有具体原型的基类或接口。</li>
<li>  <strong>具体原型（Concrete Prototype）</strong>：实现克隆方法，从自身创建一个副本。</li>
<li>  <strong>客户端（Client）</strong>：使用原型对象的客户端代码，在需要新对象时通过克隆现有对象来创建新实例。</li>
</ul>
<p><strong>效果</strong>：</p>
<p>原型模式的应用可以带来以下效果：</p>
<ul>
<li>  <strong>减少对象创建的成本</strong>：避免了复杂对象的重复初始化过程，提高了创建对象的效率。</li>
<li>  <strong>避免与具体类耦合</strong>：客户端可以通过克隆方法创建新对象，而无需知道具体类的细节，降低了耦合度。</li>
<li>  <strong>灵活性增加</strong>：可以在运行时动态地添加或删除原型，适应不同的对象创建需求。</li>
<li>  <strong>支持动态配置</strong>：可以通过克隆来定制对象的不同配置，而无需修改其代码。</li>
</ul>
<p>然而，也需要注意一些限制，如：</p>
<ul>
<li>  <strong>深克隆问题</strong>：原型模式默认进行浅克隆，即复制对象本身和其引用。如果对象内部包含其他对象的引用，可能需要实现深克隆来复制整个对象结构。</li>
<li>  <strong>克隆方法的实现</strong>：某些对象可能不容易进行克隆，特别是涉及到文件、网络连接等资源的情况。</li>
</ul>
<p>总之，原型模式是一种在需要创建对象副本时非常有用的设计模式，它提供了一种灵活且高效的方法来处理对象的复制需求。</p>
<p><strong>代码示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个实现 Cloneable 接口的原型类</span><br><span class="line">class Shape implements Cloneable &#123;</span><br><span class="line">    private String type;</span><br><span class="line"></span><br><span class="line">    public Shape(String type) &#123;</span><br><span class="line">        this.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getType() &#123;</span><br><span class="line">        return type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setType(String type) &#123;</span><br><span class="line">        this.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Shape clone() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (Shape) super.clone();</span><br><span class="line">        &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试原型模式</span><br><span class="line">public class PrototypeExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 创建原型对象</span><br><span class="line">        Shape circle = new Shape(&quot;Circle&quot;);</span><br><span class="line">        </span><br><span class="line">        // 克隆原型对象来创建新对象</span><br><span class="line">        Shape clonedCircle = circle.clone();</span><br><span class="line">        clonedCircle.setType(&quot;Cloned Circle&quot;);</span><br><span class="line"></span><br><span class="line">        // 输出原型对象和克隆对象的类型</span><br><span class="line">        System.out.println(&quot;Original Shape Type: &quot; + circle.getType());</span><br><span class="line">        System.out.println(&quot;Cloned Shape Type: &quot; + clonedCircle.getType());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-单例模式（Singleton）"><a href="#5-单例模式（Singleton）" class="headerlink" title="5. 单例模式（Singleton）"></a>5. 单例模式（Singleton）</h3><p><strong>问题：</strong></p>
<p>在某些情况下，需要确保一个类只有一个实例，并且需要一个全局访问点来访问这个实例。例如，在一个应用程序中，一个配置管理器类需要保持一致的配置数据，以避免不同部分之间的配置冲突。</p>
<p><strong>解决方案：</strong></p>
<p>单例模式通过确保一个类只能创建一个实例，并提供一个静态方法或静态属性来访问这个实例。通常，单例类会将自己的构造函数声明为私有，以防止外部代码直接创建实例。通过一个静态方法，单例类可以控制在运行时只能获得同一个实例。</p>
<p><strong>效果：</strong></p>
<p>单例模式的应用可以确保在整个应用程序中只有一个实例存在，从而节省了资源和内存。它也可以提供一个全局的访问点，使得代码中的各个部分都可以方便地获取这个实例。然而，过度使用单例模式可能导致全局状态的难以控制，以及模块之间的紧耦合。在多线程环境下需要小心处理，以确保线程安全。</p>
<p>总之，单例模式是一种常用的设计模式，适用于需要全局唯一实例的场景。它的核心思想在于通过限制类的实例化来控制对象的数量，从而保证全局唯一性。</p>
<p><strong>代码示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    // 私有静态成员变量，用于保存单例实例</span><br><span class="line">    private static Singleton instance;</span><br><span class="line">    </span><br><span class="line">    // 私有构造方法，防止外部实例化</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">        // 初始化操作</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 公共静态方法，用于获取单例实例</span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            // 如果实例为空，则创建一个新实例</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 其他成员方法</span><br><span class="line">    public void showMessage() &#123;</span><br><span class="line">        System.out.println(&quot;Hello, I am a Singleton!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 这个示例演示了如何创建一个简单的单例模式</span><br><span class="line">// 但请注意，这个实现并不是线程安全的。</span><br><span class="line">// 在多线程环境中，可能会出现多个线程同时访问getInstance()方法，导致创建多个实例的情况。</span><br><span class="line">// 为了实现线程安全的单例模式，可以使用双重检查锁定或其他同步机制。</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 获取单例实例</span><br><span class="line">        Singleton singleton = Singleton.getInstance();</span><br><span class="line">        </span><br><span class="line">        // 调用成员方法</span><br><span class="line">        singleton.showMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="6-适配器模式（Adapter）"><a href="#6-适配器模式（Adapter）" class="headerlink" title="6. 适配器模式（Adapter）"></a>6. 适配器模式（Adapter）</h3><p><strong>问题</strong>：</p>
<p>当你有两个不兼容的接口（即类或对象），但需要它们能够一起工作时，适配器模式可以解决这个问题。例如，你可能有一个已存在的类库或组件，但其接口与你的代码不匹配，你希望能够无缝地将它们集成在一起。</p>
<p><strong>解决方案</strong>：</p>
<p>适配器模式通过引入一个适配器类来充当中间人，将一个接口转换成另一个接口，使得两个不兼容的对象能够协同工作。适配器类包含一个对不兼容接口的引用，并实现了你期望的目标接口。这样，当你需要使用目标接口的时候，可以通过适配器来调用原本不兼容的类的方法。</p>
<p><strong>效果</strong>：</p>
<p>适配器模式的应用可以使得现有的代码与新代码能够无缝协同工作，从而提高了代码的可重用性。它允许你将不同系统、库或组件整合在一起，而无需对现有代码进行大量修改。然而，适配器模式也可能引入一些复杂性，因为你需要维护适配器类和处理不同接口之间的映射关系。</p>
<p>总的来说，适配器模式是一种很有用的模式，特别适合在集成不同组件或类时，解决接口不匹配的问题，从而保持代码的灵活性和可维护性。</p>
<p><strong>代码示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// 已存在的LegacyRectangle类</span><br><span class="line">class LegacyRectangle &#123;</span><br><span class="line">    public void display(int x1, int y1, int x2, int y2) &#123;</span><br><span class="line">        System.out.println(&quot;LegacyRectangle: Point1(&quot; + x1 + &quot;, &quot; + y1 + &quot;), Point2(&quot; + x2 + &quot;, &quot; + y2 + &quot;)&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 统一的Shape接口</span><br><span class="line">interface Shape &#123;</span><br><span class="line">    void draw(int x, int y, int width, int height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 适配器类，将LegacyRectangle适配到Shape接口上</span><br><span class="line">class RectangleAdapter implements Shape &#123;</span><br><span class="line">    private LegacyRectangle legacyRectangle;</span><br><span class="line"></span><br><span class="line">    public RectangleAdapter(LegacyRectangle legacyRectangle) &#123;</span><br><span class="line">        this.legacyRectangle = legacyRectangle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void draw(int x, int y, int width, int height) &#123;</span><br><span class="line">        int x1 = x;</span><br><span class="line">        int y1 = y;</span><br><span class="line">        int x2 = x + width;</span><br><span class="line">        int y2 = y + height;</span><br><span class="line">        legacyRectangle.display(x1, y1, x2, y2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在这个示例中，LegacyRectangle是已经存在的类，而RectangleAdapter是适配器类，用于将LegacyRectangle适配到Shape接口上。</span><br><span class="line">// 客户端代码通过使用适配器来画一个矩形，实际上是在调用了LegacyRectangle的display方法，但是通过适配器，它符合了Shape接口的标准。</span><br><span class="line">public class AdapterPatternExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        LegacyRectangle legacyRectangle = new LegacyRectangle();</span><br><span class="line">        Shape shapeAdapter = new RectangleAdapter(legacyRectangle);</span><br><span class="line"></span><br><span class="line">        shapeAdapter.draw(10, 20, 50, 30);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="7-桥接模式（Bridge）"><a href="#7-桥接模式（Bridge）" class="headerlink" title="7. 桥接模式（Bridge）"></a>7. 桥接模式（Bridge）</h3><p><strong>问题</strong>：</p>
<p>在软件设计中，有时候你会遇到一个类有多个变化维度（例如抽象和具体的实现）。如果使用继承来处理这些变化，将会导致类层次结构的急剧增加，难以管理和维护。此外，继承会将抽象部分和具体部分紧密耦合，不利于独立地进行扩展和变化。</p>
<p><strong>解决方案</strong>：</p>
<p>桥接模式通过将抽象部分和具体部分分离，使它们可以独立地变化。在桥接模式中，通过创建一个桥接接口（或抽象类），其中包含一个指向具体实现的引用，将抽象部分和具体部分连接起来。这样，抽象部分和具体部分可以独立地进行扩展，而不会相互影响。这种方式也被称为 “组合优于继承”。</p>
<p><strong>效果</strong>：</p>
<p>桥接模式的应用能够提供更好的灵活性和可扩展性。它允许抽象部分和具体部分独立变化，避免了类层次结构的爆炸式增长。这样可以更容易地添加新的抽象部分和具体部分，而不会影响到彼此。然而，使用桥接模式可能会引入一些复杂性，因为你需要管理更多的类和对象。</p>
<p>总之，桥接模式是一种有助于解耦抽象和实现，提供更灵活、可扩展设计的设计模式。它适用于那些需要处理多个变化维度的情况，同时又希望保持代码的清晰结构和可维护性。</p>
<p><strong>代码示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">// 实现部分 - 颜色接口</span><br><span class="line">interface Color &#123;</span><br><span class="line">    void applyColor();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Red implements Color &#123;</span><br><span class="line">    public void applyColor() &#123;</span><br><span class="line">        System.out.println(&quot;Applying red color&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Blue implements Color &#123;</span><br><span class="line">    public void applyColor() &#123;</span><br><span class="line">        System.out.println(&quot;Applying blue color&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 抽象部分 - 形状类</span><br><span class="line">abstract class Shape &#123;</span><br><span class="line">    protected Color color;</span><br><span class="line"></span><br><span class="line">    public Shape(Color color) &#123;</span><br><span class="line">        this.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    abstract void draw();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Circle extends Shape &#123;</span><br><span class="line">    public Circle(Color color) &#123;</span><br><span class="line">        super(color);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        System.out.print(&quot;Drawing a circle. &quot;);</span><br><span class="line">        color.applyColor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Square extends Shape &#123;</span><br><span class="line">    public Square(Color color) &#123;</span><br><span class="line">        super(color);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        System.out.print(&quot;Drawing a square. &quot;);</span><br><span class="line">        color.applyColor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在这个示例中，Color 接口代表颜色的实现部分，Red 和 Blue 分别是实现了颜色接口的具体颜色类。</span><br><span class="line">// Shape 是形状的抽象部分，具有一个颜色引用，而 Circle 和 Square 是继承自 Shape 的具体形状类。</span><br><span class="line">// 这种设计允许我们在不改变形状或颜色的情况下，独立地对它们进行扩展和变化。</span><br><span class="line">public class BridgePatternExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Color redColor = new Red();</span><br><span class="line">        Color blueColor = new Blue();</span><br><span class="line"></span><br><span class="line">        Shape redCircle = new Circle(redColor);</span><br><span class="line">        Shape blueSquare = new Square(blueColor);</span><br><span class="line"></span><br><span class="line">        redCircle.draw();</span><br><span class="line">        blueSquare.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="8-组合模式（Composite）"><a href="#8-组合模式（Composite）" class="headerlink" title="8. 组合模式（Composite）"></a>8. 组合模式（Composite）</h3><p><strong>问题：</strong></p>
<p>在某些情况下，我们需要处理一组对象，这些对象之间具有整体 - 部分的关系。我们希望能够以一致的方式处理单个对象和对象组合，而不需要对它们进行特殊处理。</p>
<p><strong>解决方案：</strong></p>
<p>组合模式的解决方案是将对象组合成树状结构，其中树的节点可以是单个对象或对象组合。这样，无论是操作单个对象还是对象组合，都可以使用统一的方式进行操作。组合模式通过定义一个共同的抽象类或接口来表示单个对象和对象组合，从而实现了透明的处理。</p>
<p>在组合模式中，通常有两种主要角色：</p>
<ol>
<li> <strong>组件（Component）：</strong> 这是一个抽象类或接口，定义了单个对象和对象组合共同的操作。它可以有一些默认实现，也可以有抽象方法需要在具体子类中实现。</li>
<li> <strong>叶子（Leaf）：</strong> 继承自组件，表示单个对象。它没有子对象。</li>
<li> <strong>复合（Composite）：</strong> 继承自组件，表示对象组合。它包含了一组子对象，这些子对象可以是叶子，也可以是复合。</li>
</ol>
<p><strong>效果：</strong></p>
<p>组合模式的优点包括：</p>
<ul>
<li>  <strong>透明性：</strong> 使用组合模式，客户端可以一致地对待单个对象和对象组合，无需关心具体对象的类型。</li>
<li>  <strong>简化客户端代码：</strong> 客户端不需要判断操作的对象是单个对象还是对象组合，从而简化了客户端的代码。</li>
<li>  <strong>灵活性：</strong> 可以很方便地添加新的叶子或复合对象，扩展性较好。</li>
</ul>
<p>然而，组合模式也可能带来一些限制和权衡，如：</p>
<ul>
<li>  <strong>不适合所有情况：</strong> 并非所有情况都适合使用组合模式。在一些情况下，可能会引入不必要的复杂性。</li>
<li>  <strong>可能限制操作：</strong> 组合模式可能会限制某些特定对象的操作，因为共同的抽象接口可能无法涵盖所有可能的操作。</li>
</ul>
<p>综上所述，组合模式适用于处理对象的整体 - 部分关系，并且能够提供一种统一、透明的方式来处理这些对象，从而提高代码的可维护性和扩展性。</p>
<p><strong>代码示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">// 组件接口</span><br><span class="line">interface FileSystemComponent &#123;</span><br><span class="line">    void displayInfo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 叶子节点</span><br><span class="line">class File implements FileSystemComponent &#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public File(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void displayInfo() &#123;</span><br><span class="line">        System.out.println(&quot;File: &quot; + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 容器节点</span><br><span class="line">class Directory implements FileSystemComponent &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private List&lt;FileSystemComponent&gt; components;</span><br><span class="line"></span><br><span class="line">    public Directory(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        components = new ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addComponent(FileSystemComponent component) &#123;</span><br><span class="line">        components.add(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void displayInfo() &#123;</span><br><span class="line">        System.out.println(&quot;Directory: &quot; + name);</span><br><span class="line">        for (FileSystemComponent component : components) &#123;</span><br><span class="line">            component.displayInfo();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在这个示例中，FileSystemComponent 是组合模式的组件接口，File 是叶子节点类，而 Directory 是容器节点类。</span><br><span class="line">// 通过使用这些类，我们可以构建一个具有层次结构的文件系统。</span><br><span class="line">// 注意：这只是一个简单的示例，真实的组合模式可能涉及更复杂的场景和更多的功能。</span><br><span class="line">public class CompositePatternExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 创建文件和文件夹</span><br><span class="line">        File file1 = new File(&quot;file1.txt&quot;);</span><br><span class="line">        File file2 = new File(&quot;file2.txt&quot;);</span><br><span class="line">        Directory subDirectory = new Directory(&quot;Subdirectory&quot;);</span><br><span class="line">        subDirectory.addComponent(file1);</span><br><span class="line">        subDirectory.addComponent(file2);</span><br><span class="line"></span><br><span class="line">        Directory rootDirectory = new Directory(&quot;Root&quot;);</span><br><span class="line">        rootDirectory.addComponent(subDirectory);</span><br><span class="line"></span><br><span class="line">        // 展示文件系统结构</span><br><span class="line">        rootDirectory.displayInfo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="9-装饰模式（Decorator）"><a href="#9-装饰模式（Decorator）" class="headerlink" title="9. 装饰模式（Decorator）"></a>9. 装饰模式（Decorator）</h3><p><strong>问题</strong>：</p>
<p>在某些情况下，我们需要在不修改现有对象结构的情况下，动态地添加功能或责任。继承在这种情况下可能会导致类爆炸问题，而且修改现有类可能会影响到其他部分的代码。</p>
<p><strong>解决方案</strong>：</p>
<p>装饰模式提供了一种在运行时动态地为对象添加新功能的方法，通过创建一个装饰类来包装原始类。装饰类具有与原始类相同的接口，它内部包含一个指向原始对象的引用，并且可以根据需要包装额外的功能。这样，你可以通过组合不同的装饰类来构建出具有不同功能组合的对象。</p>
<p><strong>效果</strong>：</p>
<p>装饰模式的优点包括避免了类爆炸问题，因为你可以通过组合少量的装饰类来实现各种功能组合。它也使得功能的增加和修改更加灵活，不会影响到其他部分的代码。然而，装饰模式可能会导致增加很多小型的类，从而增加了代码的复杂性。</p>
<p>在装饰模式中，通常涉及以下角色：</p>
<ol>
<li> <strong>组件（Component）</strong>：定义了一个抽象的接口，可以是具体对象或装饰器所共有的接口。</li>
<li> <strong>具体组件（Concrete Component）</strong>：实现了组件接口，是被装饰的原始对象。</li>
<li> <strong>装饰器（Decorator）</strong>：持有一个指向组件对象的引用，并实现了组件的接口。它可以包含额外的功能，也可以将请求传递给组件对象。</li>
<li> <strong>具体装饰器（Concrete Decorator）</strong>：扩展了装饰器类，通过添加额外的功能来装饰具体组件。</li>
</ol>
<p>通过这种方式，装饰模式允许你将功能嵌套地堆叠在一起，以实现各种不同的功能组合，同时保持代码的灵活性和可维护性。</p>
<p><strong>代码示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">// 首先定义一个咖啡接口</span><br><span class="line">interface Coffee &#123;</span><br><span class="line">    double cost();</span><br><span class="line">    String description();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现基本的咖啡类</span><br><span class="line">class SimpleCoffee implements Coffee &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public double cost() &#123;</span><br><span class="line">        return 2.0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String description() &#123;</span><br><span class="line">        return &quot;Simple Coffee&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建装饰器抽象类</span><br><span class="line">abstract class CoffeeDecorator implements Coffee &#123;</span><br><span class="line">    protected Coffee decoratedCoffee;</span><br><span class="line"></span><br><span class="line">    public CoffeeDecorator(Coffee coffee) &#123;</span><br><span class="line">        this.decoratedCoffee = coffee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public double cost() &#123;</span><br><span class="line">        return decoratedCoffee.cost();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String description() &#123;</span><br><span class="line">        return decoratedCoffee.description();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现具体的装饰器类</span><br><span class="line">class MilkDecorator extends CoffeeDecorator &#123;</span><br><span class="line">    public MilkDecorator(Coffee coffee) &#123;</span><br><span class="line">        super(coffee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public double cost() &#123;</span><br><span class="line">        return super.cost() + 1.0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String description() &#123;</span><br><span class="line">        return super.description() + &quot;, with Milk&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SugarDecorator extends CoffeeDecorator &#123;</span><br><span class="line">    public SugarDecorator(Coffee coffee) &#123;</span><br><span class="line">        super(coffee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public double cost() &#123;</span><br><span class="line">        return super.cost() + 0.5;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String description() &#123;</span><br><span class="line">        return super.description() + &quot;, with Sugar&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在这个示例中，Coffee 接口定义了基本的咖啡功能。SimpleCoffee 类实现了基本的咖啡。</span><br><span class="line">// CoffeeDecorator 是装饰器的抽象类，它维护一个被装饰的咖啡对象。</span><br><span class="line">// MilkDecorator 和 SugarDecorator 分别实现了具体的装饰器，通过在原始咖啡上添加新的功能。</span><br><span class="line">public class DecoratorPatternExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Coffee simpleCoffee = new SimpleCoffee();</span><br><span class="line">        System.out.println(&quot;Cost: $&quot; + simpleCoffee.cost() + &quot;, Description: &quot; + simpleCoffee.description());</span><br><span class="line"></span><br><span class="line">        Coffee milkCoffee = new MilkDecorator(simpleCoffee);</span><br><span class="line">        System.out.println(&quot;Cost: $&quot; + milkCoffee.cost() + &quot;, Description: &quot; + milkCoffee.description());</span><br><span class="line"></span><br><span class="line">        Coffee sugarMilkCoffee = new SugarDecorator(milkCoffee);</span><br><span class="line">        System.out.println(&quot;Cost: $&quot; + sugarMilkCoffee.cost() + &quot;, Description: &quot; + sugarMilkCoffee.description());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="10-外观模式（Facade）"><a href="#10-外观模式（Facade）" class="headerlink" title="10. 外观模式（Facade）"></a>10. 外观模式（Facade）</h3><p><strong>问题</strong>：</p>
<p>在软件开发中，系统可能变得非常复杂，包含多个子系统和各种交互。这些子系统之间的依赖关系和调用可能变得混乱，导致系统难以理解、扩展和维护。在这种情况下，我们需要一种方法来提供一个简单的接口，将复杂的子系统调用和依赖关系进行封装，使客户端能够更轻松地与系统进行交互。</p>
<p><strong>解决方案</strong>：</p>
<p>外观模式通过引入一个外观类（Facade），将复杂的子系统接口进行封装，为客户端提供一个简单的高层接口。外观类充当了客户端与子系统之间的中间人，处理客户端的请求并将其转发给适当的子系统。外观模式并不在系统中添加新功能，它只是提供了一个更简洁的接口，以简化客户端的操作。</p>
<p><strong>效果</strong>：</p>
<p>外观模式的应用可以带来以下效果：</p>
<ul>
<li>  <strong>简化接口</strong>：客户端只需要与外观类交互，无需了解底层子系统的复杂性。</li>
<li>  <strong>降低耦合</strong>：外观模式将客户端与子系统解耦，使得系统的变化不会影响客户端代码。</li>
<li>  <strong>提高可维护性</strong>：由于外观模式将子系统封装起来，修改子系统的实现不会影响客户端代码，从而提高了系统的可维护性。</li>
<li>  <strong>支持松散耦合</strong>：外观模式可以帮助系统中的不同模块之间实现松散耦合，从而支持模块的独立开发和测试。</li>
</ul>
<p>总之，外观模式通过提供一个简化的接口，将复杂的子系统封装起来，帮助提高系统的可用性、可维护性和灵活性。它在处理复杂系统的同时，使客户端代码更加清晰和易于理解。</p>
<p><strong>代码示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">// 子系统：音响</span><br><span class="line">class StereoSystem &#123;</span><br><span class="line">    public void turnOn() &#123;</span><br><span class="line">        System.out.println(&quot;Stereo System is turned on&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void turnOff() &#123;</span><br><span class="line">        System.out.println(&quot;Stereo System is turned off&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 子系统：投影仪</span><br><span class="line">class Projector &#123;</span><br><span class="line">    public void turnOn() &#123;</span><br><span class="line">        System.out.println(&quot;Projector is turned on&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void turnOff() &#123;</span><br><span class="line">        System.out.println(&quot;Projector is turned off&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 子系统：灯光控制</span><br><span class="line">class LightsControl &#123;</span><br><span class="line">    public void turnOn() &#123;</span><br><span class="line">        System.out.println(&quot;Lights are turned on&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void turnOff() &#123;</span><br><span class="line">        System.out.println(&quot;Lights are turned off&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 外观类：家庭影院外观</span><br><span class="line">class HomeTheaterFacade &#123;</span><br><span class="line">    private StereoSystem stereo;</span><br><span class="line">    private Projector projector;</span><br><span class="line">    private LightsControl lights;</span><br><span class="line"></span><br><span class="line">    public HomeTheaterFacade() &#123;</span><br><span class="line">        stereo = new StereoSystem();</span><br><span class="line">        projector = new Projector();</span><br><span class="line">        lights = new LightsControl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void watchMovie() &#123;</span><br><span class="line">        System.out.println(&quot;Getting ready to watch a movie...&quot;);</span><br><span class="line">        lights.turnOff();</span><br><span class="line">        projector.turnOn();</span><br><span class="line">        stereo.turnOn();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void endMovie() &#123;</span><br><span class="line">        System.out.println(&quot;Ending the movie...&quot;);</span><br><span class="line">        stereo.turnOff();</span><br><span class="line">        projector.turnOff();</span><br><span class="line">        lights.turnOn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// HomeTheaterFacade充当了一个外观类，封装了音响、投影仪和灯光控制等子系统的复杂操作，以便客户端可以通过简单的调用来完成观影过程。</span><br><span class="line">// 这样，客户端不需要了解各个子系统的具体操作，只需通过外观类的方法来控制整个家庭影院系统的行为。</span><br><span class="line">public class FacadeExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HomeTheaterFacade homeTheater = new HomeTheaterFacade();</span><br><span class="line"></span><br><span class="line">        // 准备观影</span><br><span class="line">        homeTheater.watchMovie();</span><br><span class="line"></span><br><span class="line">        // 结束观影</span><br><span class="line">        homeTheater.endMovie();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="11-享元模式（Flyweight）"><a href="#11-享元模式（Flyweight）" class="headerlink" title="11. 享元模式（Flyweight）"></a>11. 享元模式（Flyweight）</h3><p><strong>问题</strong>：</p>
<p>在某些情况下，一个应用程序可能需要大量相似对象，而这些对象的大部分属性是相同的。在这种情况下，创建大量相似对象会占用大量的内存和系统资源，导致系统性能下降。</p>
<p><strong>解决方案</strong>：</p>
<p>享元模式的解决方案是共享对象的状态，以减少内存和资源的消耗。它将对象分为两部分：内部状态（Intrinsic State）和外部状态（Extrinsic State）。内部状态是对象共享的部分，而外部状态是每个对象特有的部分。</p>
<p>享元模式通过一个享元工厂（Flyweight Factory）来管理和创建共享对象。当需要一个对象时，工厂会检查是否已经有相同内部状态的对象存在，如果存在则返回已有的对象，否则创建一个新的对象并将其添加到内部对象池中。</p>
<p><strong>效果</strong>：</p>
<ul>
<li>  <strong>优点</strong>：享元模式可以显著减少内存消耗，因为共享对象的内部状态只有一份。这可以在需要大量相似对象的情况下节省内存。同时，由于共享对象已经存在于池中，创建时间和性能开销也会降低。</li>
<li>  <strong>权衡</strong>：享元模式引入了内部状态和外部状态的区分，这可能增加了系统的复杂性。此外，对内部状态的共享需要考虑线程安全性。</li>
<li>  <strong>限制</strong>：享元模式适用于对象的内部状态相对稳定，而外部状态会变化的情况。如果一个对象的状态完全相同，那么不需要使用享元模式。</li>
<li>  <strong>可能的后果</strong>：通过减少对象的创建和内存占用，系统性能可能会得到提升。但在一些情况下，过度使用享元模式可能会引入不必要的复杂性，因此需要根据具体情况进行权衡。</li>
</ul>
<p>享元模式在需要大量相似对象的场景中非常有用，例如文字处理软件中的字符对象、图像处理软件中的像素对象等。它可以显著提高系统的性能和资源利用率。</p>
<p><strong>代码示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// 享元接口</span><br><span class="line">interface Shape &#123;</span><br><span class="line">    void draw(int x, int y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体享元类</span><br><span class="line">class Circle implements Shape &#123;</span><br><span class="line">    private Color color;</span><br><span class="line"></span><br><span class="line">    public Circle(Color color) &#123;</span><br><span class="line">        this.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void draw(int x, int y) &#123;</span><br><span class="line">        System.out.println(&quot;Drawing a &quot; + color + &quot; circle at (&quot; + x + &quot;,&quot; + y + &quot;)&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 享元工厂类</span><br><span class="line">class ShapeFactory &#123;</span><br><span class="line">    private static final Map&lt;Color, Shape&gt; circleMap = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public static Shape getCircle(Color color) &#123;</span><br><span class="line">        Shape circle = circleMap.get(color);</span><br><span class="line"></span><br><span class="line">        if (circle == null) &#123;</span><br><span class="line">            circle = new Circle(color);</span><br><span class="line">            circleMap.put(color, circle);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return circle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在这个示例中，我们定义了一个Shape接口和一个具体的Circle类来表示享元对象。</span><br><span class="line">// ShapeFactory类负责管理共享的对象池，并通过getCircle方法返回共享的或新创建的圆形对象。</span><br><span class="line">// 在main函数中，我们随机选择不同的颜色，并使用ShapeFactory获取对应的圆形对象，然后调用draw方法绘制它们。</span><br><span class="line">public class FlyweightPatternExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Color[] colors = &#123;Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW&#125;;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">            Color randomColor = colors[(int) (Math.random() * colors.length)];</span><br><span class="line">            Shape circle = ShapeFactory.getCircle(randomColor);</span><br><span class="line">            circle.draw((int) (Math.random() * 100), (int) (Math.random() * 100));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="12-代理模式（Proxy）"><a href="#12-代理模式（Proxy）" class="headerlink" title="12. 代理模式（Proxy）"></a>12. 代理模式（Proxy）</h3><p><strong>问题：</strong></p>
<p>在某些情况下，我们希望通过一个中间代理来控制对某个对象的访问。这可能是因为原始对象的创建或访问涉及复杂的逻辑，或者我们想要在访问原始对象之前或之后执行一些操作。</p>
<p><strong>解决方案：</strong></p>
<p>代理模式提供了一个代理对象，它充当了原始对象的替代品，以控制对原始对象的访问。代理对象与原始对象实现相同的接口，使得客户端可以无缝地切换和使用。代理对象可以对客户端的请求进行拦截、修改或增强，然后将请求传递给原始对象。</p>
<p><strong>效果：</strong></p>
<p>代理模式的应用可以带来多种效果：</p>
<ul>
<li>  <strong>远程代理（Remote Proxy）：</strong> 代理对象可以隐藏原始对象存在于远程服务器上的事实，使得客户端可以透明地访问远程对象。这对于分布式系统非常有用。</li>
<li>  <strong>虚拟代理（Virtual Proxy）：</strong> 当创建原始对象需要大量资源时，代理对象可以充当一个轻量级的替代品，延迟原始对象的实际创建和初始化，从而提高性能。</li>
<li>  <strong>保护代理（Protection Proxy）：</strong> 代理对象可以控制对原始对象的访问权限，确保只有具有特定权限的客户端可以访问原始对象。</li>
<li>  <strong>缓存代理（Cache Proxy）：</strong> 代理对象可以缓存原始对象的结果，以便在后续相同请求时能够直接返回缓存的结果，减少重复计算。</li>
<li>  <strong>日志记录代理（Logging Proxy）：</strong> 代理对象可以在访问原始对象之前或之后记录日志，用于调试、监控或审计。</li>
</ul>
<p>总之，代理模式允许我们在不改变原始对象的情况下，通过引入代理对象来添加额外的控制和功能。这有助于提高代码的可维护性、可扩展性和灵活性。</p>
<p><strong>代码示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">// 图像接口</span><br><span class="line">interface Image &#123;</span><br><span class="line">    void display();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 真实图像类</span><br><span class="line">class RealImage implements Image &#123;</span><br><span class="line">    private String filename;</span><br><span class="line"></span><br><span class="line">    public RealImage(String filename) &#123;</span><br><span class="line">        this.filename = filename;</span><br><span class="line">        loadImageFromDisk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void loadImageFromDisk() &#123;</span><br><span class="line">        System.out.println(&quot;Loading image from disk: &quot; + filename);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void display() &#123;</span><br><span class="line">        System.out.println(&quot;Displaying image: &quot; + filename);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 代理图像类</span><br><span class="line">class ProxyImage implements Image &#123;</span><br><span class="line">    private RealImage realImage;</span><br><span class="line">    private String filename;</span><br><span class="line"></span><br><span class="line">    public ProxyImage(String filename) &#123;</span><br><span class="line">        this.filename = filename;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void display() &#123;</span><br><span class="line">        if (realImage == null) &#123;</span><br><span class="line">            realImage = new RealImage(filename);</span><br><span class="line">        &#125;</span><br><span class="line">        realImage.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在这个示例中，Image接口定义了display方法，RealImage是实际的图像加载类，而ProxyImage是代理图像类。</span><br><span class="line">// 当ProxyImage的display方法被调用时，它会在需要时创建一个RealImage实例，并调用其display方法。</span><br><span class="line">public class ProxyPatternExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Image image = new ProxyImage(&quot;sample.jpg&quot;);</span><br><span class="line"></span><br><span class="line">        // 图像未加载，直到调用display()方法</span><br><span class="line">        image.display();</span><br><span class="line"></span><br><span class="line">        // 图像已加载，无需再次创建</span><br><span class="line">        image.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="13-解释器模式（Interpreter）"><a href="#13-解释器模式（Interpreter）" class="headerlink" title="13. 解释器模式（Interpreter）"></a>13. 解释器模式（Interpreter）</h3><p><strong>问题</strong>：</p>
<p>在某些情况下，你可能需要解释和处理一种特定语言或表达式。这可能涉及到解析、分析和执行这些语言或表达式，但在每个具体情况下，解释的方式都可能不同。</p>
<p><strong>解决方案</strong>：</p>
<p>解释器模式通过定义一种语言文法的表示，并提供一种解释器来解释这种语言的语句。这样，你可以将语句表示为抽象语法树，然后通过解释器逐步执行和解释这个语法树。</p>
<ul>
<li>  <strong>抽象表达式（Abstract Expression）</strong>：定义了一个抽象的解释方法，所有的具体表达式都需要实现这个接口。</li>
<li>  <strong>终结符表达式（Terminal Expression）</strong>：实现了抽象表达式接口，用于表示语言中的终结符（最小的语法单元）。</li>
<li>  <strong>非终结符表达式（Non-terminal Expression）</strong>：实现了抽象表达式接口，用于表示语言中的非终结符，通常由多个终结符和 / 或其他非终结符组成的组合。</li>
<li>  <strong>上下文（Context）</strong>：包含了需要被解释的信息，通常包括输入的语句和解释器。</li>
<li>  <strong>解释器（Interpreter）</strong>：包含了解释器模式的主要逻辑，它通过递归的方式对抽象语法树进行解释，实现了语言中各种语句的解释和执行。</li>
</ul>
<p><strong>效果</strong>：</p>
<p>解释器模式的使用可以使你更容易地实现特定语言的解释和执行，尤其在处理自定义的领域特定语言（DSL）时非常有用。然而，解释器模式可能导致类的数量增加，因为每个语法规则都需要一个相应的表达式类。此外，解释器模式可能会对性能产生影响，特别是在处理复杂语法时。</p>
<p>总之，解释器模式适用于需要解释和处理特定语言或表达式的情况，它通过将语句表示为抽象语法树并提供解释器来执行解释。这有助于实现定制的语言处理逻辑。</p>
<p><strong>代码示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">// 表达式接口</span><br><span class="line">interface Expression &#123;</span><br><span class="line">    int interpret();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 数字表达式类</span><br><span class="line">class NumberExpression implements Expression &#123;</span><br><span class="line">    private int value;</span><br><span class="line">    </span><br><span class="line">    public NumberExpression(int value) &#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public int interpret() &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 加法表达式类</span><br><span class="line">class AddExpression implements Expression &#123;</span><br><span class="line">    private Expression leftOperand;</span><br><span class="line">    private Expression rightOperand;</span><br><span class="line">    </span><br><span class="line">    public AddExpression(Expression leftOperand, Expression rightOperand) &#123;</span><br><span class="line">        this.leftOperand = leftOperand;</span><br><span class="line">        this.rightOperand = rightOperand;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public int interpret() &#123;</span><br><span class="line">        return leftOperand.interpret() + rightOperand.interpret();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 减法表达式类</span><br><span class="line">class SubtractExpression implements Expression &#123;</span><br><span class="line">    private Expression leftOperand;</span><br><span class="line">    private Expression rightOperand;</span><br><span class="line">    </span><br><span class="line">    public SubtractExpression(Expression leftOperand, Expression rightOperand) &#123;</span><br><span class="line">        this.leftOperand = leftOperand;</span><br><span class="line">        this.rightOperand = rightOperand;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public int interpret() &#123;</span><br><span class="line">        return leftOperand.interpret() - rightOperand.interpret();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在这个示例中，我们构建了一个简单的数学表达式解释器，用于解释并计算基本的加法和减法表达式。</span><br><span class="line">// 这展示了解释器模式如何工作，将表达式解释成实际的结果。</span><br><span class="line">// 在实际应用中，解释器模式可以用于更复杂的领域，如编程语言解释器或规则引擎。</span><br><span class="line">public class InterpreterPatternExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 构建表达式：2 + (3 - 1)</span><br><span class="line">        Expression expression = new AddExpression(</span><br><span class="line">            new NumberExpression(2),</span><br><span class="line">            new SubtractExpression(</span><br><span class="line">                new NumberExpression(3),</span><br><span class="line">                new NumberExpression(1)</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        // 解释并计算表达式的值</span><br><span class="line">        int result = expression.interpret();</span><br><span class="line">        System.out.println(&quot;Result: &quot; + result); // 输出: Result: 4</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="14-模板方法模式（Template-Method）"><a href="#14-模板方法模式（Template-Method）" class="headerlink" title="14. 模板方法模式（Template Method）"></a>14. 模板方法模式（Template Method）</h3><p><strong>问题：</strong></p>
<p>当你在设计一个类或一组类时，发现有一些算法的结构是固定的，但其中的某些步骤可能会因应用情境或子类的不同而变化。你希望将这个算法的核心结构固定下来，但留出一些灵活性来允许特定步骤的定制。</p>
<p><strong>解决方案：</strong></p>
<p>模板方法模式通过定义一个抽象的父类，其中包含了算法的核心结构，但某些步骤使用抽象方法或受保护的虚拟方法来表示，这些方法由子类来实现。这使得子类可以根据需要重写特定的步骤，而核心算法结构保持不变。父类中的模板方法调用这些步骤，确保算法的整体流程一致。</p>
<p><strong>效果：</strong></p>
<p>模板方法模式的效果包括：</p>
<ul>
<li>  <strong>代码复用：</strong> 核心算法结构在父类中定义，可以被多个子类共享，避免了重复的代码。</li>
<li>  <strong>灵活性：</strong> 子类可以通过实现特定的步骤来定制算法的行为，而不需要改变算法的整体结构。</li>
<li>  <strong>可维护性：</strong> 将算法的核心结构集中在一个地方，易于维护和修改。</li>
<li>  <strong>代码一致性：</strong> 所有子类共享相同的算法模板，确保了算法的一致性。</li>
</ul>
<p><strong>示例：</strong></p>
<p>想象你正在设计一个咖啡和茶的准备流程。虽然两者的基本步骤相似（烧水、冲泡、添加调味品等），但是每种饮料的具体步骤略有不同。你可以使用模板方法模式来创建一个饮料准备的抽象类，其中包含烧水、冲泡和倒入杯中等通用步骤，但将冲泡的细节留给子类来实现（如茶类和咖啡类）。</p>
<p>这样，你就能在不改变整体流程的情况下，让不同的饮料类定制它们的冲泡过程。这遵循了模板方法模式的思想，将共享的算法结构与可变的部分分离，以便实现代码的重用和灵活性。</p>
<p><strong>代码示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// 模板类</span><br><span class="line">abstract class AbstractClass &#123;</span><br><span class="line">    // 模板方法，定义算法的骨架</span><br><span class="line">    public void templateMethod() &#123;</span><br><span class="line">        step1();</span><br><span class="line">        step2();</span><br><span class="line">        step3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 基本方法，子类需要实现</span><br><span class="line">    abstract void step1();</span><br><span class="line">    abstract void step2();</span><br><span class="line">    abstract void step3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体子类实现</span><br><span class="line">class ConcreteClass extends AbstractClass &#123;</span><br><span class="line">    @Override</span><br><span class="line">    void step1() &#123;</span><br><span class="line">        System.out.println(&quot;ConcreteClass: Step 1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void step2() &#123;</span><br><span class="line">        System.out.println(&quot;ConcreteClass: Step 2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void step3() &#123;</span><br><span class="line">        System.out.println(&quot;ConcreteClass: Step 3&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在上面的示例中，AbstractClass 是模板类，定义了一个包含三个步骤的模板方法 templateMethod</span><br><span class="line">// 这些步骤由抽象方法 step1、step2 和 step3 构成。ConcreteClass 是具体子类，继承自 AbstractClass，它实现了基本方法来完成每个步骤的具体行为。</span><br><span class="line">// 在 main 方法中，我们创建了一个 ConcreteClass 实例并调用了 templateMethod，这会按照模板的结构执行具体的步骤。</span><br><span class="line">public class TemplateMethodExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AbstractClass template = new ConcreteClass();</span><br><span class="line">        template.templateMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="15-责任链模式（Chain-of-Responsibility）"><a href="#15-责任链模式（Chain-of-Responsibility）" class="headerlink" title="15. 责任链模式（Chain of Responsibility）"></a>15. 责任链模式（Chain of Responsibility）</h3><p><strong>问题</strong>：</p>
<p>在某些情况下，一个请求需要在多个对象之间传递，每个对象都可能处理该请求或将其传递给下一个对象。在这种情况下，需要避免将发送者与接收者之间的耦合，以及确定请求的处理方式。问题在于如何设计一个机制，使得多个对象都有机会处理请求，而且可以根据需要动态地改变它们之间的顺序和职责。</p>
<p><strong>解决方案</strong>：</p>
<p>责任链模式提供了一种通过一系列处理对象来处理请求的方法。每个处理对象都包含一个对下一个处理对象的引用，形成一个链式结构。当一个请求到达时，它首先被传递给链中的第一个处理对象，如果该对象不能处理该请求，它会将请求传递给下一个处理对象，依此类推，直到找到能够处理请求的对象为止。</p>
<p>责任链模式的解决方案包括以下关键点：</p>
<ul>
<li>  定义一个抽象处理者（Handler）类，该类包含一个对下一个处理者的引用，并声明一个处理请求的方法。</li>
<li>  具体的处理者类继承自抽象处理者类，实现处理请求的方法。在该方法中，处理者可以决定是否处理请求，如果不能处理，则将请求传递给下一个处理者。</li>
<li>  客户端创建一个处理链，将处理者按照一定的顺序连接起来。</li>
</ul>
<p><strong>效果</strong>：</p>
<p>责任链模式的应用可以带来多个效果：</p>
<ul>
<li>  <strong>降低耦合度</strong>：发送者不需要知道哪个对象会处理请求，只需将请求发送到链的起始点。</li>
<li>  <strong>灵活性</strong>：可以根据需要动态地改变处理链中处理者的顺序，以及每个处理者的职责。</li>
<li>  <strong>可扩展性</strong>：可以很容易地添加新的处理者，而不会影响现有代码。</li>
<li>  <strong>可维护性</strong>：每个处理者关注单一的责任，使得代码更易于理解和维护。</li>
</ul>
<p>然而，责任链模式也有一些潜在的限制，比如可能导致请求无法被处理或者处理链太长而导致性能问题。因此，在使用责任链模式时需要谨慎权衡权衡利弊。</p>
<p>总之，责任链模式是一种有助于将请求与处理者解耦，并支持动态调整处理顺序和职责的设计模式。</p>
<p><strong>代码示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">// 首先，我们需要创建一个表示请求的类 ReimbursementRequest</span><br><span class="line">public class ReimbursementRequest &#123;</span><br><span class="line">    private double amount;</span><br><span class="line">    private String description;</span><br><span class="line"></span><br><span class="line">    public ReimbursementRequest(double amount, String description) &#123;</span><br><span class="line">        this.amount = amount;</span><br><span class="line">        this.description = description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double getAmount() &#123;</span><br><span class="line">        return amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getDescription() &#123;</span><br><span class="line">        return description;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 然后，创建一个抽象处理者类 ReimbursementHandler</span><br><span class="line">public abstract class ReimbursementHandler &#123;</span><br><span class="line">    protected ReimbursementHandler successor;</span><br><span class="line"></span><br><span class="line">    public void setSuccessor(ReimbursementHandler successor) &#123;</span><br><span class="line">        this.successor = successor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract void handleRequest(ReimbursementRequest request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 接下来，实现具体的处理者类：经理、部门主管和财务部门处理者。</span><br><span class="line">public class ManagerHandler extends ReimbursementHandler &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void handleRequest(ReimbursementRequest request) &#123;</span><br><span class="line">        if (request.getAmount() &lt;= 1000) &#123;</span><br><span class="line">            System.out.println(&quot;经理处理报销请求：&quot; + request.getDescription());</span><br><span class="line">        &#125; else if (successor != null) &#123;</span><br><span class="line">            successor.handleRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class DepartmentHeadHandler extends ReimbursementHandler &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void handleRequest(ReimbursementRequest request) &#123;</span><br><span class="line">        if (request.getAmount() &lt;= 5000) &#123;</span><br><span class="line">            System.out.println(&quot;部门主管处理报销请求：&quot; + request.getDescription());</span><br><span class="line">        &#125; else if (successor != null) &#123;</span><br><span class="line">            successor.handleRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class FinanceHandler extends ReimbursementHandler &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void handleRequest(ReimbursementRequest request) &#123;</span><br><span class="line">        System.out.println(&quot;财务部门处理报销请求：&quot; + request.getDescription());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在这个示例中，报销请求会依次被经理、部门主管和财务部门处理。根据报销金额的不同，请求会被传递到适当的处理者。</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ReimbursementHandler manager = new ManagerHandler();</span><br><span class="line">        ReimbursementHandler departmentHead = new DepartmentHeadHandler();</span><br><span class="line">        ReimbursementHandler finance = new FinanceHandler();</span><br><span class="line"></span><br><span class="line">        manager.setSuccessor(departmentHead);</span><br><span class="line">        departmentHead.setSuccessor(finance);</span><br><span class="line"></span><br><span class="line">        ReimbursementRequest request1 = new ReimbursementRequest(800, &quot;购买办公用品&quot;);</span><br><span class="line">        ReimbursementRequest request2 = new ReimbursementRequest(3000, &quot;参加培训&quot;);</span><br><span class="line">        ReimbursementRequest request3 = new ReimbursementRequest(10000, &quot;举办团建活动&quot;);</span><br><span class="line"></span><br><span class="line">        manager.handleRequest(request1);</span><br><span class="line">        manager.handleRequest(request2);</span><br><span class="line">        manager.handleRequest(request3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="16-命令模式（Command）"><a href="#16-命令模式（Command）" class="headerlink" title="16. 命令模式（Command）"></a>16. 命令模式（Command）</h3><p><strong>问题</strong>：</p>
<p>在某些情况下，你希望将请求发送者与接收者解耦，从而允许您以不同的方式组织和处理请求。例如，您可能希望将请求排队、记录、撤消或重做，而无需修改发送者和接收者之间的代码。</p>
<p><strong>解决方案</strong>：</p>
<p>命令模式提供了一种将请求封装成对象的方法，使得请求的发送者与请求的接收者之间不直接耦合。这通过引入以下角色实现：</p>
<ol>
<li> <strong>命令（Command）</strong>：抽象命令类，定义了执行命令的接口。它通常包含一个执行方法，以及可能的其他方法（例如，撤消）。</li>
<li> <strong>具体命令（Concrete Command）</strong>：实现了抽象命令类的具体子类，将一个接收者与一个动作绑定。它实现了执行方法，该方法调用接收者的特定操作。</li>
<li> <strong>接收者（Receiver）</strong>：执行实际工作的类。命令模式将命令传递给接收者，由接收者执行实际的操作。</li>
<li> <strong>调用者 / 请求者（Invoker）</strong>：负责将命令传递给合适的接收者并触发命令的执行。它并不关心具体的命令细节。</li>
<li> <strong>客户端（Client）</strong>：创建命令对象、接收者对象以及调用者对象，并将它们组织起来以实现特定的操作流程。</li>
</ol>
<p><strong>效果</strong>：</p>
<p>命令模式的效果在于解耦命令的发送者和接收者，从而支持更灵活的代码组织。它允许您轻松地添加新的命令，排队命令，记录命令历史，甚至实现撤消和重做功能。然而，命令模式也可能引入一些复杂性，因为您需要为每个操作创建一个具体命令类。</p>
<p>总的来说，命令模式在需要解耦请求发送者和接收者，并支持灵活的命令处理时非常有用。它在菜单系统、GUI 操作、多级撤销等场景中得到广泛应用。</p>
<p><strong>代码示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">// 命令接口</span><br><span class="line">interface Command &#123;</span><br><span class="line">    void execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体命令：控制电灯打开</span><br><span class="line">class LightOnCommand implements Command &#123;</span><br><span class="line">    private Light light;</span><br><span class="line"></span><br><span class="line">    public LightOnCommand(Light light) &#123;</span><br><span class="line">        this.light = light;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void execute() &#123;</span><br><span class="line">        light.turnOn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体命令：控制电灯关闭</span><br><span class="line">class LightOffCommand implements Command &#123;</span><br><span class="line">    private Light light;</span><br><span class="line"></span><br><span class="line">    public LightOffCommand(Light light) &#123;</span><br><span class="line">        this.light = light;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void execute() &#123;</span><br><span class="line">        light.turnOff();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 电灯类</span><br><span class="line">class Light &#123;</span><br><span class="line">    void turnOn() &#123;</span><br><span class="line">        System.out.println(&quot;Light is on&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void turnOff() &#123;</span><br><span class="line">        System.out.println(&quot;Light is off&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 遥控器类</span><br><span class="line">class RemoteControl &#123;</span><br><span class="line">    private Command command;</span><br><span class="line"></span><br><span class="line">    public void setCommand(Command command) &#123;</span><br><span class="line">        this.command = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void pressButton() &#123;</span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在这个示例中，我们使用命令模式创建了两种具体的命令：打开电灯和关闭电灯。</span><br><span class="line">// 遥控器可以设置不同的命令，然后按下按钮触发相应的操作。</span><br><span class="line">// 这样，命令发送者（遥控器）和命令接收者（电灯）之间实现了解耦。</span><br><span class="line">public class CommandPatternExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Light livingRoomLight = new Light();</span><br><span class="line">        </span><br><span class="line">        LightOnCommand livingRoomLightOn = new LightOnCommand(livingRoomLight);</span><br><span class="line">        LightOffCommand livingRoomLightOff = new LightOffCommand(livingRoomLight);</span><br><span class="line">        </span><br><span class="line">        RemoteControl remote = new RemoteControl();</span><br><span class="line">        </span><br><span class="line">        remote.setCommand(livingRoomLightOn);</span><br><span class="line">        remote.pressButton(); // 打开电灯</span><br><span class="line">        </span><br><span class="line">        remote.setCommand(livingRoomLightOff);</span><br><span class="line">        remote.pressButton(); // 关闭电灯</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="17-迭代器模式（Iterator）"><a href="#17-迭代器模式（Iterator）" class="headerlink" title="17. 迭代器模式（Iterator）"></a>17. 迭代器模式（Iterator）</h3><p><strong>问题</strong>：</p>
<p>在软件开发中，经常需要遍历集合（如列表、数组、树等）中的元素，但不同集合可能有不同的遍历方式，这导致在客户端代码中需要编写不同的遍历逻辑，使代码变得复杂且难以维护。此外，有时候还需要在遍历过程中支持添加、删除等操作，这可能会影响遍历的一致性和正确性。</p>
<p><strong>解决方案</strong>：</p>
<p>迭代器模式提供了一种统一的方法来遍历不同类型的集合，而无需暴露集合内部的表示细节。它包括两个主要组件：迭代器和集合。迭代器负责遍历集合并提供统一的访问接口，而集合负责实际存储元素。迭代器和集合之间的解耦使得可以独立地改变它们的实现，而不会影响到客户端代码。</p>
<p><strong>效果</strong>：</p>
<ul>
<li>  优点：迭代器模式将遍历操作封装在迭代器中，使客户端代码更加简洁、可读，并且降低了与集合的耦合。它也提供了支持多种遍历方式的灵活性，如正向遍历、逆向遍历等。</li>
<li>  权衡：迭代器模式可能会增加一些额外的类和接口，可能会稍微增加复杂性，但从长远来看，可以提高代码的可维护性和可扩展性。</li>
<li>  限制：迭代器模式并不适用于所有情况。在一些简单的情况下，直接使用语言内置的遍历机制可能更为方便。</li>
</ul>
<p>总之，迭代器模式提供了一种解决集合遍历问题的通用方法，使得代码更具结构和可维护性。它在各种编程语言和应用中都有广泛的应用。</p>
<p><strong>代码示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个可迭代的集合接口</span><br><span class="line">interface IterableCollection&lt;T&gt; &#123;</span><br><span class="line">    Iterator&lt;T&gt; createIterator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体的集合类实现可迭代的集合接口</span><br><span class="line">class ConcreteCollection&lt;T&gt; implements IterableCollection&lt;T&gt; &#123;</span><br><span class="line">    private List&lt;T&gt; items = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public void addItem(T item) &#123;</span><br><span class="line">        items.add(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Iterator&lt;T&gt; createIterator() &#123;</span><br><span class="line">        return new ConcreteIterator&lt;&gt;(items);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义迭代器接口</span><br><span class="line">interface Iterator&lt;T&gt; &#123;</span><br><span class="line">    boolean hasNext();</span><br><span class="line"></span><br><span class="line">    T next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体迭代器实现迭代器接口</span><br><span class="line">class ConcreteIterator&lt;T&gt; implements Iterator&lt;T&gt; &#123;</span><br><span class="line">    private List&lt;T&gt; items;</span><br><span class="line">    private int position = 0;</span><br><span class="line"></span><br><span class="line">    public ConcreteIterator(List&lt;T&gt; items) &#123;</span><br><span class="line">        this.items = items;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean hasNext() &#123;</span><br><span class="line">        return position &lt; items.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public T next() &#123;</span><br><span class="line">        if (hasNext()) &#123;</span><br><span class="line">            T item = items.get(position);</span><br><span class="line">            position++;</span><br><span class="line">            return item;</span><br><span class="line">        &#125;</span><br><span class="line">        throw new IndexOutOfBoundsException(&quot;No more elements&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在这个示例中，我们定义了一个IterableCollection接口来表示可迭代的集合，一个具体的集合类ConcreteCollection实现了这个接口，并提供了一个用于创建迭代器的方法。</span><br><span class="line">// 迭代器接口Iterator定义了hasNext和next方法，具体的迭代器类ConcreteIterator实现了这个接口，并通过内部的位置追踪来遍历集合。</span><br><span class="line">public class IteratorPatternExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ConcreteCollection&lt;String&gt; collection = new ConcreteCollection&lt;&gt;();</span><br><span class="line">        collection.addItem(&quot;Item 1&quot;);</span><br><span class="line">        collection.addItem(&quot;Item 2&quot;);</span><br><span class="line">        collection.addItem(&quot;Item 3&quot;);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;String&gt; iterator = collection.createIterator();</span><br><span class="line">        while (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="18-中介者模式（Mediator）"><a href="#18-中介者模式（Mediator）" class="headerlink" title="18. 中介者模式（Mediator）"></a>18. 中介者模式（Mediator）</h3><p><strong>问题</strong>：</p>
<p>在一个系统中，对象之间的通信可能会变得复杂，导致对象之间相互依赖，难以管理和维护。当对象之间的通信变得混乱时，就需要一个方法来将通信逻辑集中管理，从而减少耦合度并提高系统的可维护性。</p>
<p><strong>解决方案</strong>：</p>
<p>中介者模式引入了一个中介者对象，它负责协调和管理对象之间的通信。对象不再直接与其他对象通信，而是通过中介者来发送和接收消息。这样一来，对象只需要关注自己的职责，而不需要了解其他对象的详细信息。中介者模式的核心思想是将复杂的交互逻辑集中到一个地方，以便更好地管理和调整。</p>
<p><strong>效果</strong>：</p>
<ul>
<li>  <strong>降低耦合度</strong>：对象之间的通信逻辑被集中在中介者中，从而降低了对象之间的直接依赖，减少了耦合度，使系统更加灵活和可维护。</li>
<li>  <strong>集中管理</strong>：所有对象的交互逻辑都集中在中介者中，使得系统的交互逻辑更加清晰可见，便于管理和修改。</li>
<li>  <strong>复用性</strong>：中介者模式将交互逻辑与对象本身的业务逻辑分离，可以更容易地复用这些交互逻辑。</li>
<li>  <strong>可扩展性</strong>：通过增加或修改中介者对象，可以相对容易地扩展系统，而不需要修改对象之间的通信逻辑。</li>
</ul>
<p>需要注意的是，中介者模式可能会引入一个单一的中心化点，如果设计不当，可能会导致中介者对象本身变得过于复杂。因此，在使用中介者模式时，需要权衡考虑系统的复杂性和灵活性。</p>
<p><strong>代码示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">// 中介者接口</span><br><span class="line">interface ChatMediator &#123;</span><br><span class="line">    void sendMessage(String message, User user);</span><br><span class="line">    void addUser(User user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体中介者类</span><br><span class="line">class ConcreteChatMediator implements ChatMediator &#123;</span><br><span class="line">    private List&lt;User&gt; users = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void sendMessage(String message, User user) &#123;</span><br><span class="line">        for (User u : users) &#123;</span><br><span class="line">            if (u != user) &#123;</span><br><span class="line">                u.receiveMessage(message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addUser(User user) &#123;</span><br><span class="line">        users.add(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 用户类</span><br><span class="line">class User &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private ChatMediator mediator;</span><br><span class="line"></span><br><span class="line">    public User(String name, ChatMediator mediator) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void sendMessage(String message) &#123;</span><br><span class="line">        System.out.println(name + &quot; 发送消息: &quot; + message);</span><br><span class="line">        mediator.sendMessage(message, this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void receiveMessage(String message) &#123;</span><br><span class="line">        System.out.println(name + &quot; 收到消息: &quot; + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在这个示例中，ConcreteChatMediator 实现了 ChatMediator 接口，并管理用户列表。</span><br><span class="line">// 每个用户对象在构造时都传递了中介者实例，以便用户可以使用中介者发送和接收消息。</span><br><span class="line">public class MediatorPatternExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ConcreteChatMediator chatMediator = new ConcreteChatMediator();</span><br><span class="line"></span><br><span class="line">        User user1 = new User(&quot;Alice&quot;, chatMediator);</span><br><span class="line">        User user2 = new User(&quot;Bob&quot;, chatMediator);</span><br><span class="line">        User user3 = new User(&quot;Charlie&quot;, chatMediator);</span><br><span class="line"></span><br><span class="line">        chatMediator.addUser(user1);</span><br><span class="line">        chatMediator.addUser(user2);</span><br><span class="line">        chatMediator.addUser(user3);</span><br><span class="line"></span><br><span class="line">        user1.sendMessage(&quot;大家好！&quot;);</span><br><span class="line">        user2.sendMessage(&quot;你好，Alice！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="19-备忘录模式（Memento）"><a href="#19-备忘录模式（Memento）" class="headerlink" title="19. 备忘录模式（Memento）"></a>19. 备忘录模式（Memento）</h3><p><strong>问题</strong>：</p>
<p>在软件设计中，经常会遇到需要记录一个对象的内部状态，并在需要时能够回滚到先前的状态。这可能是为了实现撤销操作、历史记录功能等。</p>
<p><strong>解决方案</strong>：</p>
<p>备忘录模式通过引入 “备忘录” 对象，允许在不暴露对象内部结构的情况下，捕获并存储对象的状态。同时，它还提供了一种将对象恢复到之前状态的方式。备忘录模式包括以下角色：</p>
<ul>
<li>  <strong>Originator（发起人）</strong>：这是需要被记录状态的对象。它创建一个备忘录对象，以存储当前状态，也可以从备忘录中恢复状态。</li>
<li>  <strong>Memento（备忘录）</strong>：备忘录对象用于存储 Originator 的状态。通常，备忘录对象具有与原始对象相同的接口，但不会直接暴露其内部状态。</li>
<li>  <strong>Caretaker（负责人）</strong>：负责管理备忘录对象。它可以存储多个备忘录对象，以便在需要时进行状态恢复。</li>
</ul>
<p><strong>效果</strong>：</p>
<p>备忘录模式使得对象的状态管理更加灵活。它允许对象在不暴露其内部结构的情况下进行状态的保存和恢复。这有助于实现撤销和重做功能，以及历史记录和快照功能。然而，使用备忘录模式可能会增加一些内存开销，特别是如果需要存储大量的状态历史。</p>
<p>总之，备忘录模式在需要记录和恢复对象状态的情况下是一个有用的设计模式。它可以帮助保持代码的清晰性和可维护性，同时提供强大的状态管理功能。</p>
<p><strong>代码示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">// 备忘录类</span><br><span class="line">class Memento &#123;</span><br><span class="line">    private String state;</span><br><span class="line"></span><br><span class="line">    public Memento(String state) &#123;</span><br><span class="line">        this.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getState() &#123;</span><br><span class="line">        return state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 原始对象类</span><br><span class="line">class Originator &#123;</span><br><span class="line">    private String state;</span><br><span class="line"></span><br><span class="line">    public void setState(String state) &#123;</span><br><span class="line">        this.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getState() &#123;</span><br><span class="line">        return state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Memento createMemento() &#123;</span><br><span class="line">        return new Memento(state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void restoreMemento(Memento memento) &#123;</span><br><span class="line">        state = memento.getState();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 管理者类</span><br><span class="line">class Caretaker &#123;</span><br><span class="line">    private Memento memento;</span><br><span class="line"></span><br><span class="line">    public Memento getMemento() &#123;</span><br><span class="line">        return memento;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMemento(Memento memento) &#123;</span><br><span class="line">        this.memento = memento;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在这个示例中，Originator 类表示原始对象，它具有状态并能够创建和恢复备忘录。</span><br><span class="line">// Memento 类表示备忘录对象，保存了特定时刻的状态。Caretaker 类负责保存和获取备忘录对象。</span><br><span class="line">// 通过设置初始状态、创建备忘录、修改状态、然后恢复状态，我们可以看到备忘录模式的工作方式。</span><br><span class="line">public class MementoPatternExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Originator originator = new Originator();</span><br><span class="line">        Caretaker caretaker = new Caretaker();</span><br><span class="line"></span><br><span class="line">        // 设置初始状态</span><br><span class="line">        originator.setState(&quot;State 1&quot;);</span><br><span class="line">        System.out.println(&quot;Current State: &quot; + originator.getState());</span><br><span class="line"></span><br><span class="line">        // 创建备忘录并保存状态</span><br><span class="line">        caretaker.setMemento(originator.createMemento());</span><br><span class="line"></span><br><span class="line">        // 修改状态</span><br><span class="line">        originator.setState(&quot;State 2&quot;);</span><br><span class="line">        System.out.println(&quot;Updated State: &quot; + originator.getState());</span><br><span class="line"></span><br><span class="line">        // 恢复之前的状态</span><br><span class="line">        originator.restoreMemento(caretaker.getMemento());</span><br><span class="line">        System.out.println(&quot;Restored State: &quot; + originator.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="20-观察者模式（Observer）"><a href="#20-观察者模式（Observer）" class="headerlink" title="20. 观察者模式（Observer）"></a>20. 观察者模式（Observer）</h3><p><strong>问题</strong>：</p>
<p>在软件设计中，经常会遇到这样的情况：一个对象（主题）的状态发生改变，而其他对象（观察者）需要在状态改变时得到通知并进行相应的更新。但是，如果直接在对象之间建立硬编码的依赖关系，会导致系统的耦合度增加，难以维护和扩展。观察者模式试图解决这个问题，允许主题和观察者之间的松耦合通信。</p>
<p><strong>解决方案</strong>：</p>
<p>观察者模式的核心思想是定义一种一对多的依赖关系，使得一个主题（通常称为被观察者）可以同时维护多个观察者，并在其状态改变时自动通知所有观察者。这样，观察者无需关心主题的内部实现细节，而只需要关心主题的状态变化。在实现中，通常会定义一个抽象的主题类和一个抽象的观察者类，具体的主题和观察者类会继承这些抽象类并实现相应的方法。</p>
<p><strong>效果</strong>：</p>
<p>观察者模式的应用有以下优点：</p>
<ul>
<li>  <strong>松耦合</strong>：主题和观察者之间的耦合度降低，使得它们可以独立地进行变化。</li>
<li>  <strong>可扩展性</strong>：可以方便地增加新的观察者，而不会影响到已有的观察者和主题。</li>
<li>  <strong>自动通知</strong>：主题状态改变时会自动通知观察者，减少手动维护通知的工作。</li>
<li>  <strong>可重用性</strong>：主题和观察者可以在不同的场景中重复使用。</li>
</ul>
<p>然而，观察者模式也有一些限制和权衡：</p>
<ul>
<li>  <strong>可能引起性能问题</strong>：如果观察者过多或通知机制不合理，可能会导致性能下降。</li>
<li>  <strong>更新顺序问题</strong>：观察者的更新顺序可能会影响到系统的行为，需要特别注意。</li>
<li>  <strong>过度使用的风险</strong>：并不是所有的状态变化都适合使用观察者模式，过度使用可能导致代码复杂化。</li>
</ul>
<p>总之，观察者模式是一种用于解决对象间状态通知和更新的重要设计模式，它在许多软件系统中都有广泛的应用。</p>
<p><strong>代码示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">// 主题接口</span><br><span class="line">interface Subject &#123;</span><br><span class="line">    void addObserver(Observer observer);</span><br><span class="line">    void removeObserver(Observer observer);</span><br><span class="line">    void notifyObservers();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体主题类</span><br><span class="line">class ConcreteSubject implements Subject &#123;</span><br><span class="line">    private List&lt;Observer&gt; observers = new ArrayList&lt;&gt;();</span><br><span class="line">    private int state;</span><br><span class="line"></span><br><span class="line">    public int getState() &#123;</span><br><span class="line">        return state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setState(int state) &#123;</span><br><span class="line">        this.state = state;</span><br><span class="line">        notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addObserver(Observer observer) &#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void removeObserver(Observer observer) &#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void notifyObservers() &#123;</span><br><span class="line">        for (Observer observer : observers) &#123;</span><br><span class="line">            observer.update(state);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 观察者接口</span><br><span class="line">interface Observer &#123;</span><br><span class="line">    void update(int state);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体观察者类</span><br><span class="line">class ConcreteObserver implements Observer &#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public ConcreteObserver(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void update(int state) &#123;</span><br><span class="line">        System.out.println(name + &quot; 收到更新，新状态为: &quot; + state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在这个示例中，ConcreteSubject 充当主题（被观察者），ConcreteObserver 充当观察者。</span><br><span class="line">// 主题维护一个观察者列表，并在状态变化时通知所有观察者。</span><br><span class="line">// 当主题的状态发生变化时，所有观察者都会被通知并更新自己的状态。</span><br><span class="line">public class ObserverPatternExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ConcreteSubject subject = new ConcreteSubject();</span><br><span class="line"></span><br><span class="line">        Observer observer1 = new ConcreteObserver(&quot;观察者1&quot;);</span><br><span class="line">        Observer observer2 = new ConcreteObserver(&quot;观察者2&quot;);</span><br><span class="line"></span><br><span class="line">        subject.addObserver(observer1);</span><br><span class="line">        subject.addObserver(observer2);</span><br><span class="line"></span><br><span class="line">        subject.setState(10);</span><br><span class="line">        subject.setState(20);</span><br><span class="line"></span><br><span class="line">        subject.removeObserver(observer1);</span><br><span class="line"></span><br><span class="line">        subject.setState(30);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="21-状态模式（State）"><a href="#21-状态模式（State）" class="headerlink" title="21. 状态模式（State）"></a>21. 状态模式（State）</h3><p><strong>问题：</strong></p>
<p>当一个对象的行为在不同状态下发生改变，并且对象需要根据其状态执行不同的操作时，就可以考虑使用状态模式。在这种情况下，如果直接在对象内部实现所有状态之间的切换逻辑，会导致代码变得复杂且难以维护。</p>
<p><strong>解决方案：</strong></p>
<p>状态模式的解决方案是将对象的状态抽象成独立的状态类，每个状态类都实现了一组特定状态下的操作。然后，上下文对象（即包含状态的对象）维护一个指向当前状态的引用，通过委托给当前状态的方法来执行操作。这种方式可以将不同状态下的行为逻辑分隔开来，使得状态变化时的代码修改更加容易。</p>
<p><strong>效果：</strong></p>
<p>使用状态模式可以实现以下效果：</p>
<ul>
<li>  <strong>清晰的状态切换：</strong> 状态模式将每个状态的行为集中在各自的状态类中，使得状态切换的逻辑变得清晰，易于管理和修改。</li>
<li>  <strong>可维护性：</strong> 将状态相关的代码分布在不同的状态类中，使得代码更加模块化和可维护。</li>
<li>  <strong>扩展性：</strong> 添加新的状态只需要创建新的状态类并实现相关操作，不会影响到其他状态类或上下文类的代码。</li>
<li>  <strong>避免条件语句：</strong> 状态模式避免了大量的条件语句，从而提高了代码的可读性和可维护性。</li>
<li>  <strong>复用性：</strong> 状态类之间的逻辑可以被复用，因为它们是独立的实体。</li>
</ul>
<p>总之，状态模式使得对象在不同状态下能够更加灵活地切换行为，同时保持了代码的可维护性和可扩展性。它在需要处理复杂状态逻辑的情况下特别有用。</p>
<p><strong>代码示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">// 状态接口</span><br><span class="line">interface ElevatorState &#123;</span><br><span class="line">    void openDoors();</span><br><span class="line">    void closeDoors();</span><br><span class="line">    void move();</span><br><span class="line">    void stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体状态类：开门状态</span><br><span class="line">class OpenState implements ElevatorState &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void openDoors() &#123;</span><br><span class="line">        System.out.println(&quot;Doors are already open.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void closeDoors() &#123;</span><br><span class="line">        System.out.println(&quot;Closing doors.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void move() &#123;</span><br><span class="line">        System.out.println(&quot;Cannot move while doors are open.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void stop() &#123;</span><br><span class="line">        System.out.println(&quot;Stopping while doors are open.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体状态类：关门状态</span><br><span class="line">class CloseState implements ElevatorState &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void openDoors() &#123;</span><br><span class="line">        System.out.println(&quot;Opening doors.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void closeDoors() &#123;</span><br><span class="line">        System.out.println(&quot;Doors are already closed.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void move() &#123;</span><br><span class="line">        System.out.println(&quot;Moving.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void stop() &#123;</span><br><span class="line">        System.out.println(&quot;Stopping.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 上下文类：电梯</span><br><span class="line">class Elevator &#123;</span><br><span class="line">    private ElevatorState state;</span><br><span class="line"></span><br><span class="line">    public Elevator() &#123;</span><br><span class="line">        state = new CloseState(); // 初始状态为关门状态</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setState(ElevatorState state) &#123;</span><br><span class="line">        this.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void openDoors() &#123;</span><br><span class="line">        state.openDoors();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void closeDoors() &#123;</span><br><span class="line">        state.closeDoors();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void move() &#123;</span><br><span class="line">        state.move();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void stop() &#123;</span><br><span class="line">        state.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在这个示例中，我们创建了一个模拟电梯系统，其中有开门状态和关门状态两个具体状态类，以及电梯类作为上下文类。</span><br><span class="line">// 通过切换状态，电梯在不同状态下有不同的行为表现。这就是状态模式的基本思想。</span><br><span class="line">public class StatePatternExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Elevator elevator = new Elevator();</span><br><span class="line"></span><br><span class="line">        elevator.openDoors(); // 当前状态：开门</span><br><span class="line">        elevator.move();      // 当前状态：开门，无法移动</span><br><span class="line">        elevator.closeDoors(); // 当前状态：关门</span><br><span class="line">        elevator.move();       // 当前状态：移动中</span><br><span class="line">        elevator.stop();       // 当前状态：停止</span><br><span class="line">        elevator.openDoors();  // 当前状态：开门</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="22-策略模式（Strategy）"><a href="#22-策略模式（Strategy）" class="headerlink" title="22. 策略模式（Strategy）"></a>22. 策略模式（Strategy）</h3><p><strong>问题</strong>：</p>
<p>在某些情况下，一个软件系统可能需要根据不同的情境或条件使用不同的算法或行为，但是这些算法的选择和使用可能会频繁变化。如果将这些算法都硬编码在主要的类中，会导致代码的臃肿不堪，难以维护和扩展。需要一种方式来灵活地选择和切换不同的算法，同时又不影响到客户端代码。</p>
<p><strong>解决方案</strong>：</p>
<p>策略模式提供了一种定义一系列算法的方法，将这些算法封装成独立的策略类，并使它们可以相互替换。在客户端中，创建一个上下文（Context）对象，该对象包含一个对策略类的引用，通过该引用调用相应的策略方法。这样，客户端可以在运行时选择不同的策略，而不需要修改上下文类。</p>
<p><strong>效果</strong>：</p>
<p>策略模式的主要优点是实现了算法的解耦，使得算法可以独立于客户端而变化。它提高了代码的可维护性和扩展性，因为新的策略可以很容易地添加到系统中。然而，策略模式也可能导致类的数量增加，因为每个算法都需要一个对应的策略类。在使用策略模式时，需要权衡类的数量与灵活性之间的关系。</p>
<p>总之，策略模式是一种非常有用的设计模式，特别适用于需要根据情境灵活选择不同算法或行为的场景，帮助保持代码的结构清晰且易于维护。</p>
<p><strong>代码示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">// 首先，我们定义一个接口 MathOperation，表示数学操作的策略</span><br><span class="line">// 定义策略接口</span><br><span class="line">interface MathOperation &#123;</span><br><span class="line">    int operate(int a, int b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现加法策略</span><br><span class="line">class Addition implements MathOperation &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int operate(int a, int b) &#123;</span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现减法策略</span><br><span class="line">class Subtraction implements MathOperation &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int operate(int a, int b) &#123;</span><br><span class="line">        return a - b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现乘法策略</span><br><span class="line">class Multiplication implements MathOperation &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int operate(int a, int b) &#123;</span><br><span class="line">        return a * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 然后，我们创建一个 Calculator 类，它接受一个数学操作策略，并根据用户的选择执行相应的操作</span><br><span class="line">class Calculator &#123;</span><br><span class="line">    private MathOperation operation;</span><br><span class="line"></span><br><span class="line">    public void setOperation(MathOperation operation) &#123;</span><br><span class="line">        this.operation = operation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int performOperation(int a, int b) &#123;</span><br><span class="line">        if (operation != null) &#123;</span><br><span class="line">            return operation.operate(a, b);</span><br><span class="line">        &#125;</span><br><span class="line">        throw new IllegalStateException(&quot;No operation set&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 在这个示例中，我们通过创建不同的数学操作策略类来实现加法、减法和乘法功能，并通过设置不同的策略来执行不同的操作。这就是策略模式的基本思想。</span><br><span class="line">public class StrategyPatternExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Calculator calculator = new Calculator();</span><br><span class="line"></span><br><span class="line">        calculator.setOperation(new Addition());</span><br><span class="line">        int result1 = calculator.performOperation(5, 3);</span><br><span class="line">        System.out.println(&quot;Addition Result: &quot; + result1);</span><br><span class="line"></span><br><span class="line">        calculator.setOperation(new Subtraction());</span><br><span class="line">        int result2 = calculator.performOperation(10, 4);</span><br><span class="line">        System.out.println(&quot;Subtraction Result: &quot; + result2);</span><br><span class="line"></span><br><span class="line">        calculator.setOperation(new Multiplication());</span><br><span class="line">        int result3 = calculator.performOperation(6, 2);</span><br><span class="line">        System.out.println(&quot;Multiplication Result: &quot; + result3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="23-访问者模式（Visitor）"><a href="#23-访问者模式（Visitor）" class="headerlink" title="23. 访问者模式（Visitor）"></a>23. 访问者模式（Visitor）</h3><p><strong>问题</strong>：</p>
<p>在面向对象设计中，当一个对象结构中的元素类（例如，不同类型的对象）需要进行多种不同的操作时，常常会导致操作与元素的类相耦合，从而难以扩展新的操作而不影响现有的类。此外，每次添加新的操作都需要修改已存在的元素类。</p>
<p><strong>解决方案</strong>：</p>
<p>访问者模式提出了一种解决方案，使得可以在不修改元素类的情况下，将操作从元素类中分离出来。它的核心思想是引入一个称为 “访问者” 的接口或类，该访问者包含了多个访问操作，每个操作对应一个元素类。元素类接受访问者，从而将自身传递给访问者，使得访问者可以对元素执行相应的操作。</p>
<p><strong>效果</strong>：</p>
<ul>
<li>  <strong>分离关注点</strong>：访问者模式将元素类与具体操作分离，使得每个类可以专注于自身的职责，而操作则由访问者来实现。</li>
<li>  <strong>易于扩展</strong>：添加新的操作只需要增加一个新的访问者，不需要修改已存在的元素类，因此对系统的扩展更加容易。</li>
<li>  <strong>可维护性</strong>：由于每个操作被封装在独立的访问者中，使得代码更加清晰、易于维护。</li>
<li>  <strong>灵活性</strong>：可以在不修改元素类的情况下，动态地添加新的操作。</li>
<li>  <strong>不适用于频繁变化的元素类</strong>：如果元素类经常发生变化，会导致频繁修改访问者接口和实现。</li>
</ul>
<p>总之，访问者模式适用于需要对一组不同类型的对象执行多种不同操作的情况。它在维护、扩展和修改代码时提供了更好的灵活性和可维护性。</p>
<p><strong>代码示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">// 首先，我们需要定义图形形状的接口和具体类</span><br><span class="line">// 图形形状接口</span><br><span class="line">interface Shape &#123;</span><br><span class="line">    void accept(ShapeVisitor visitor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 圆形类</span><br><span class="line">class Circle implements Shape &#123;</span><br><span class="line">    private double radius;</span><br><span class="line"></span><br><span class="line">    public Circle(double radius) &#123;</span><br><span class="line">        this.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double getRadius() &#123;</span><br><span class="line">        return radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void accept(ShapeVisitor visitor) &#123;</span><br><span class="line">        visitor.visit(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 矩形类</span><br><span class="line">class Rectangle implements Shape &#123;</span><br><span class="line">    private double width;</span><br><span class="line">    private double height;</span><br><span class="line"></span><br><span class="line">    public Rectangle(double width, double height) &#123;</span><br><span class="line">        this.width = width;</span><br><span class="line">        this.height = height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double getWidth() &#123;</span><br><span class="line">        return width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double getHeight() &#123;</span><br><span class="line">        return height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void accept(ShapeVisitor visitor) &#123;</span><br><span class="line">        visitor.visit(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 接下来，定义一个访问者接口和具体的访问者实现</span><br><span class="line">// 访问者接口</span><br><span class="line">interface ShapeVisitor &#123;</span><br><span class="line">    void visit(Circle circle);</span><br><span class="line">    void visit(Rectangle rectangle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 面积计算访问者</span><br><span class="line">class AreaCalculator implements ShapeVisitor &#123;</span><br><span class="line">    private double area;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void visit(Circle circle) &#123;</span><br><span class="line">        area += Math.PI * circle.getRadius() * circle.getRadius();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void visit(Rectangle rectangle) &#123;</span><br><span class="line">        area += rectangle.getWidth() * rectangle.getHeight();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double getArea() &#123;</span><br><span class="line">        return area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 在这个示例中，访问者模式允许我们在不修改形状类的情况下，通过实现不同的访问者来执行不同的操作，例如计算面积。</span><br><span class="line">// 这样，我们可以轻松地添加新的访问者来执行其他操作，同时保持形状类的不变。</span><br><span class="line">public class VisitorPatternExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Circle circle = new Circle(5);</span><br><span class="line">        Rectangle rectangle = new Rectangle(4, 6);</span><br><span class="line"></span><br><span class="line">        AreaCalculator areaCalculator = new AreaCalculator();</span><br><span class="line">        circle.accept(areaCalculator);</span><br><span class="line">        rectangle.accept(areaCalculator);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;Total area: &quot; + areaCalculator.getArea());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<div class="article-footer reveal fs14"><section id="share"><div class="header"><span>分享文章</span></div><div class="body"><div class="link"><input class="copy-area" readonly="true" id="copy-link" value="https://su3.cn/2024/08/02/2024080202/" /></div><div class="social-wrap dis-select"><a class="social share-item wechat" onclick="util.toggle(&quot;qrcode-wechat&quot)"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/social/b32ef3da1162a.svg"/></a><a class="social share-item weibo" target="_blank" rel="external nofollow noopener noreferrer" href="https://service.weibo.com/share/share.php?url=https://su3.cn/2024/08/02/2024080202/&title=Java 中常用的 23 种设计模式详解2 - 苏三博客&summary=Java 中常用的 23 种设计模式详解"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/social/80c07e4dbb303.svg"/></a><a class="social share-item email" href="mailto:?subject=Java 中常用的 23 种设计模式详解2 - 苏三博客&amp;body=https://su3.cn/2024/08/02/2024080202/"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/social/a1b00e20f425d.svg"/></a><a class="social share-item link" onclick="util.copy(&quot;copy-link&quot;, &quot;复制成功&quot;)"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/social/8411ed322ced6.svg"/></a></div><div class="qrcode" id="qrcode-wechat" style="visibility:hidden;height:0"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://api.qrserver.com/v1/create-qr-code/?size=256x256&data=https://su3.cn/2024/08/02/2024080202/"/></div></div></section></div>

</article>

<div class="related-wrap reveal" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/2024/08/02/2024080201/">Java 中常用的 23 种设计模式详解1</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/2024/08/01/2024080102/">finalshell样式配置</a></div></section></div>






  <div class='related-wrap md-text reveal' id="comments">
    <section class='header cmt-title cap theme'>
      快来参与讨论吧
    </section>
    <section class='body cmt-body giscus'>
      

<svg class="loading" style="vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2709"><path d="M832 512c0-176-144-320-320-320V128c211.2 0 384 172.8 384 384h-64zM192 512c0 176 144 320 320 320v64C300.8 896 128 723.2 128 512h64z" p-id="2710"></path></svg>

<div id="giscus" data-repo="zhhltc/blogcomments" data-repo-id="R_kgDOI35Puw" data-category="Announcements" data-category-id="DIC_kwDOI35Pu84CT54y" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="preferred_color_scheme" data-lang="zh-CN" data-loading="lazy" crossorigin="anonymous"></div>

    </section>
  </div>



      
<footer class="page-footer reveal fs12"><hr><div class="text"><div class="BeiAn-info" style="display: flex;text-align: center;margin:10px;justify-content: center; align-items: center;"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/p/imgs/beian.png" title="备案管理系统" style="width:15px;height:15px;"> <a href="http://beian.miit.gov.cn/" style="text-decoration:none;" target=_blank title=备案号>赣ICP备17016237号-1</a></div><div  style="display: flex;text-align: center;justify-content: center; align-items: center;"><span id="timeDate">载入天数...</span>|<span id="times">载入时分秒...</span><span class="post-meta-divider">|</span><span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span><span class="post-meta-divider">|</span><span id="busuanzi_container_site_uv" style="display:none">本站访客数<span id="busuanzi_value_site_uv"></span>人</span></div><script type="text/javascript" src="/js/jquery-3.5.1.min.js"></script><script type="text/javascript" src="/js/dist/zoomify.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></footer>

<!--添加网站运行时间 -->
<!--<br/>-->

<script>
    var now = new Date();

    function createtime() {
        var grt = new Date("11/01/2021 12:00:00");
        now.setTime(now.getTime() + 250);
        days = (now - grt) / 1000 / 60 / 60 / 24;
        dnum = Math.floor(days);
        hours = (now - grt) / 1000 / 60 / 60 - (24 * dnum);
        hnum = Math.floor(hours);
        if (String(hnum).length == 1) {
            hnum = "0" + hnum;
        }
        minutes = (now - grt) / 1000 / 60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes);
        if (String(mnum).length == 1) {
            mnum = "0" + mnum;
        }
        seconds = (now - grt) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds);
        if (String(snum).length == 1) {
            snum = "0" + snum;
        }
        document.getElementById("timeDate").innerHTML = "本站已安全运行 " + dnum + " 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
    setInterval("createtime()", 250);
</script>
<!-- 添加网站运行时间》 -->

<style>
  /*返回顶部的css*/
.All_url_totop{
position:fixed;right:10px;width: 35px;height: 35px; border-radius: 5px; position: fixed;right: 10px; cursor: pointer;background-repeat: no-repeat; background-position: 50% 50%; background-color: #000; opacity: .1; transition: opacity .2s ease-in-out;z-index: 99999;
}
#All_url_totop{
background-image:url(data:img/png;base64,R0lGODlhEgAUAJEAAAAAAP///////wAAACH5BAEAAAIALAAAAAASABQAAAImjI+py+IPo4xmWmRpyq5dFkzgoY3VY5KS9ykcKy6vnMEr3W417hQAOw==);
top:384px;
}
#All_url_totop2{
background-image:url(data:img/png;base64,R0lGODlhEgAUAJEAAAAAAP///////wAAACH5BAEAAAIALAAAAAASABQAAAIqlB2peX27nINKNsoswnrTLmABKJKcJH5PGl3siKZdabZgWN2rzuPv/yoAADs=);
top:429px;
}
#All_url_totop:hover,
#All_url_totop2:hover{
opacity: .5;
}
</style>

<script>
 if (!window.location.href.includes("music")) {
        window.onload = function () {
          /*添加返回顶部按钮*/
          var a = document.createElement("a");
          a.setAttribute("href", "JavaScript:window.scrollTo(0,0);");
          a.setAttribute("id", "All_url_totop")
          a.setAttribute("class", "All_url_totop");
          document.body.appendChild(a);
          /*添加返回底部的按钮*/
          var a = document.createElement("a");
          a.setAttribute("href", "JavaScript:window.scrollTo(0,document.body.scrollHeight);");
          a.setAttribute("id", "All_url_totop2")
          a.setAttribute("class", "All_url_totop");
          document.body.appendChild(a);
        }
      }
</script>

        
        <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

      
    </div>
  </div>
  <div class='scripts'>
    <script type="text/javascript">
  const stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')){
        src = stellar.config.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.version = '1.19.0';
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.19.0';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
    root : '/',
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://gcore.jsdelivr.net/npm/jquery@3.6.2/dist/jquery.min.js'
  };

  if ('local_search') {
    stellar.search = {};
    stellar.search.service = 'local_search';
    if (stellar.search.service == 'local_search') {
      let service_obj = Object.assign({}, {"field":"all","path":"/search.json","content":true,"sort":"-date"});
      stellar.search[stellar.search.service] = service_obj;
    }
  }

  // stellar js
  stellar.plugins.stellar = Object.assign({"sites":"/js/plugins/sites.js","friends":"/js/plugins/friends.js","ghinfo":"/js/plugins/ghinfo.js","timeline":"/js/plugins/timeline.js","linkcard":"/js/plugins/linkcard.js","fcircle":"/js/plugins/fcircle.js","weibo":"/js/plugins/weibo.js"});

  stellar.plugins.marked = Object.assign("https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js");
  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/vanilla-lazyload@17.8.3/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@8.4.5/swiper-bundle.min.css","js":"https://unpkg.com/swiper@8.4.5/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://gcore.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://gcore.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://gcore.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.fancybox = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js","css":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css","selector":".swiper-slide img"});
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://unpkg.com/heti@0.9.2/umd/heti.min.css","js":"https://unpkg.com/heti@0.9.2/umd/heti-addon.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.copycode = Object.assign({"enable":true,"js":"/js/plugins/copycode.js","default_text":"Copy","success_text":"Copied"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->

  <script>
  function loadJS() {
    const els = document.querySelectorAll("#comments #giscus");
    if (els.length === 0) return;
    els.forEach((el, i) => {
      try {
        el.innerHTML = '';
      } catch (error) {
        console.log(error);
      }
      var script = document.createElement('script');
      script.src = 'https://giscus.app/client.js';
      script.async = true;
      for (let key of Object.keys(el.attributes)) {
        let attr = el.attributes[key];
        if (['class', 'id'].includes(attr.name) === false) {
          script.setAttribute(attr.name, attr.value);
        }
      }
      el.appendChild(script);
    });
  }
  window.addEventListener('DOMContentLoaded', (event) => {
    loadJS();
  });
</script>




<!-- inject -->


  </div>
</body>
</html>
