<!DOCTYPE html>
<html lang='zh-CN'>

<head>
  <meta name="generator" content="Hexo 5.4.0">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.19.0">
  <meta charset="utf-8">
  

  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://gcore.jsdelivr.net'>
  <link rel="preconnect" href="https://gcore.jsdelivr.net" crossorigin>
  <link rel='dns-prefetch' href='//unpkg.com'>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  
  <title>Java 中常用的 23 种设计模式详解1 - 苏三博客</title>

  
    <meta name="description" content="Java 中常用的 23 种设计模式详解">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 中常用的 23 种设计模式详解1">
<meta property="og:url" content="https://su3.cn/2024/08/02/2024080201/index.html">
<meta property="og:site_name" content="苏三博客">
<meta property="og:description" content="Java 中常用的 23 种设计模式详解">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-08-02T10:00:00.000Z">
<meta property="article:modified_time" content="2025-12-16T09:08:08.836Z">
<meta property="article:author" content="SuSan">
<meta property="article:tag" content="笔记">
<meta name="twitter:card" content="summary">
  
  
  
  <meta name="keywords" content="笔记">

  <!-- feed -->
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  

  

  


  
    
      <link href="https://gcore.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@1.1.0/lxgwwenkaiscreen.css" rel="stylesheet">
    
  
</head>

<body>
  




  <div class='l_body' id='start'>
    <aside class='l_left' layout='post'>
    

  

<header class="header"><div class="logo-wrap"><a class="avatar"  style="width:52px;height:52px;" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="/pic.jpg" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/image/2659360.svg';"></a><a class="title" href="/"><div class="main" ff="title" style="font-size: 1.12rem;">苏三博客</div><div class="sub cap" style="margin-top:3px;font-size:10px;color:#CD853F;">- Su3.cn 无限制,有些线路较慢</div><div class="sub cap" style="margin-top:3px;font-size:10px;color:green;">- Xen.cc 静态资源托管加速,限流</div></a></div>

<nav class="menu dis-select"><a class="nav-item active" href="/">博客</a><a class="nav-item" href="/utils/">工具</a><a class="nav-item" href="/music/">歌单</a><a class="nav-item" href="/about/">更多</a></nav>
</header>


<div class="widgets">

<widget class="widget-wrapper toc single" id="data-toc"><div class="widget-header cap dis-select"><span class="name">Java 中常用的 23 种设计模式详解1</span></div><div class="widget-body fs14"><div class="doc-tree active"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%88Creational-Patterns%EF%BC%89"><span class="toc-text">一、创建型模式（Creational Patterns）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88Singleton-Pattern%EF%BC%89"><span class="toc-text">1.1 单例模式（Singleton Pattern）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%88Prototype-Pattern%EF%BC%89"><span class="toc-text">1.2 原型模式（Prototype Pattern）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88Builder-Pattern%EF%BC%89"><span class="toc-text">1.3 建造者模式（Builder Pattern）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%EF%BC%88Factory-Method-Pattern%EF%BC%89"><span class="toc-text">1.4 工厂方法模式（Factory Method Pattern）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%88Abstract-Factory-Pattern%EF%BC%89"><span class="toc-text">1.5 抽象工厂模式（Abstract Factory Pattern）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%88Structural-Patterns%EF%BC%89"><span class="toc-text">二、结构型模式（Structural Patterns）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88Adapter-Pattern%EF%BC%89"><span class="toc-text">2.1 适配器模式（Adapter Pattern）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%EF%BC%88Bridge-Pattern%EF%BC%89"><span class="toc-text">2.2 桥接模式（Bridge Pattern）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%EF%BC%88Composite-Pattern%EF%BC%89"><span class="toc-text">2.3 组合模式（Composite Pattern）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88Decorator-Pattern%EF%BC%89"><span class="toc-text">2.4 装饰器模式（Decorator Pattern）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%EF%BC%88Facade-Pattern%EF%BC%89"><span class="toc-text">2.5 外观模式（Facade Pattern）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%EF%BC%88Flyweight-Pattern%EF%BC%89"><span class="toc-text">2.6 享元模式（Flyweight Pattern）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%EF%BC%88Proxy-Pattern%EF%BC%89"><span class="toc-text">2.7 代理模式（Proxy Pattern）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%88Behavioral-Patterns%EF%BC%89"><span class="toc-text">三、行为型模式（Behavioral Patterns）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%EF%BC%88Chain-of-Responsibility-Pattern%EF%BC%89"><span class="toc-text">3.1 责任链模式（Chain of Responsibility Pattern）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%EF%BC%88Command-Pattern%EF%BC%89"><span class="toc-text">3.2 命令模式（Command Pattern）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88Iterator-Pattern%EF%BC%89"><span class="toc-text">3.3 迭代器模式（Iterator Pattern）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88Mediator-Pattern%EF%BC%89"><span class="toc-text">3.4 中介者模式（Mediator Pattern）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%EF%BC%88Memento-Pattern%EF%BC%89"><span class="toc-text">3.5 备忘录模式（Memento Pattern）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88Interpreter-Pattern%EF%BC%89"><span class="toc-text">3.6 解释器模式（Interpreter Pattern）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%EF%BC%88State-Pattern%EF%BC%89"><span class="toc-text">3.7 状态模式（State Pattern）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-8-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%EF%BC%88Strategy-Pattern%EF%BC%89"><span class="toc-text">3.8 策略模式（Strategy Pattern）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-9-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%EF%BC%88Template-Method-Pattern%EF%BC%89"><span class="toc-text">3.9 模板方法模式（Template Method Pattern）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-10-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88Visitor-Pattern%EF%BC%89"><span class="toc-text">3.10 访问者模式（Visitor Pattern）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-11-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88Observer-Pattern%EF%BC%89"><span class="toc-text">3.11 观察者模式（Observer Pattern）</span></a></li></ol></li></ol></div></div></widget>




</div>


    </aside>
    <div class='l_main'>
      

      



<div class="bread-nav fs12"><div id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a><span class="sep"></span><a class="cap breadcrumb" href="/">文章</a><span class="sep"></span><a class="cap breadcrumb-link" href="/categories/Java/">Java</a></div><div id="post-meta">发布于&nbsp;<time datetime="2024-08-02T10:00:00.000Z">2024-08-02</time></div></div>

<article class='md-text content post'>
<h1 class="article-title"><span>Java 中常用的 23 种设计模式详解1</span></h1>
<p>设计模式是软件开发中的最佳实践，帮助开发者在面对复杂设计问题时提供有效的解决方案。GoF（Gang of Four）在其经典著作《设计模式：可复用面向对象软件的基础》中定义了 23 种设计模式。。本文将详细介绍 23 种经典设计模式，包括创建型模式、结构型模式和行为型模式，提供每种模式的定义、原理、优点、Java 示例代码以及详细注释。</p>
<h3 id="一、创建型模式（Creational-Patterns）"><a href="#一、创建型模式（Creational-Patterns）" class="headerlink" title="一、创建型模式（Creational Patterns）"></a>一、创建型模式（Creational Patterns）</h3><p>创建型模式关注于对象的创建，提供了更灵活的对象创建方式。</p>
<h4 id="1-1-单例模式（Singleton-Pattern）"><a href="#1-1-单例模式（Singleton-Pattern）" class="headerlink" title="1.1 单例模式（Singleton Pattern）"></a>1.1 单例模式（Singleton Pattern）</h4><p><strong>定义</strong>：确保一个类只有一个实例，并提供一个全局访问点。</p>
<p><strong>原理</strong>：通过私有化构造函数和提供一个静态方法来获取实例。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>  <strong>控制实例数量</strong>：保证只有一个实例。</li>
<li>  <strong>提供全局访问点</strong>：方便在全局范围内访问该实例。</li>
</ul>
<p><strong>Java 示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 单例类</span><br><span class="line">public class Singleton &#123;</span><br><span class="line">    // 唯一实例</span><br><span class="line">    private static Singleton instance;</span><br><span class="line"></span><br><span class="line">    // 私有构造函数，防止外部实例化</span><br><span class="line">    private Singleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // 提供全局访问点</span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            instance = new Singleton();  // 懒汉式加载</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1-2-原型模式（Prototype-Pattern）"><a href="#1-2-原型模式（Prototype-Pattern）" class="headerlink" title="1.2 原型模式（Prototype Pattern）"></a>1.2 原型模式（Prototype Pattern）</h4><p><strong>定义</strong>：通过复制现有的实例来创建新实例，而不是通过构造函数。</p>
<p><strong>原理</strong>：实现 <code>Cloneable</code> 接口并重写 <code>clone()</code> 方法来复制对象。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>  <strong>减少创建新对象的开销</strong>：通过复制现有对象创建新对象。</li>
<li>  <strong>动态配置对象</strong>：可以在运行时配置对象状态。</li>
</ul>
<p><strong>Java 示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 原型接口</span><br><span class="line">public interface Prototype extends Cloneable &#123;</span><br><span class="line">    Prototype clone();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体原型类</span><br><span class="line">public class ConcretePrototype implements Prototype &#123;</span><br><span class="line">    private String data;</span><br><span class="line"></span><br><span class="line">    public ConcretePrototype(String data) &#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Prototype clone() &#123;</span><br><span class="line">        return new ConcretePrototype(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getData() &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 客户端代码</span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ConcretePrototype prototype = new ConcretePrototype(&quot;Prototype Data&quot;);</span><br><span class="line">        ConcretePrototype clonedPrototype = (ConcretePrototype) prototype.clone();</span><br><span class="line">        System.out.println(clonedPrototype.getData());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1-3-建造者模式（Builder-Pattern）"><a href="#1-3-建造者模式（Builder-Pattern）" class="headerlink" title="1.3 建造者模式（Builder Pattern）"></a>1.3 建造者模式（Builder Pattern）</h4><p><strong>定义</strong>：使用多个简单的对象一步一步构建一个复杂的对象。</p>
<p><strong>原理</strong>：定义一个建造者接口和具体建造者类，通过建造者类来创建复杂对象。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>  <strong>解耦</strong>：将复杂对象的构建与表示解耦。</li>
<li>  <strong>灵活性</strong>：可以根据需要创建不同表示的复杂对象。</li>
</ul>
<p><strong>Java 示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">// 产品类</span><br><span class="line">public class Product &#123;</span><br><span class="line">    private String partA;</span><br><span class="line">    private String partB;</span><br><span class="line"></span><br><span class="line">    // 构造函数</span><br><span class="line">    public Product(String partA, String partB) &#123;</span><br><span class="line">        this.partA = partA;</span><br><span class="line">        this.partB = partB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Product [partA=&quot; + partA + &quot;, partB=&quot; + partB + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 建造者接口</span><br><span class="line">public interface Builder &#123;</span><br><span class="line">    void buildPartA();</span><br><span class="line">    void buildPartB();</span><br><span class="line">    Product getResult();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体建造者类</span><br><span class="line">public class ConcreteBuilder implements Builder &#123;</span><br><span class="line">    private String partA;</span><br><span class="line">    private String partB;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void buildPartA() &#123;</span><br><span class="line">        partA = &quot;Part A&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void buildPartB() &#123;</span><br><span class="line">        partB = &quot;Part B&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Product getResult() &#123;</span><br><span class="line">        return new Product(partA, partB);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 指导者类</span><br><span class="line">public class Director &#123;</span><br><span class="line">    private Builder builder;</span><br><span class="line"></span><br><span class="line">    public Director(Builder builder) &#123;</span><br><span class="line">        this.builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void construct() &#123;</span><br><span class="line">        builder.buildPartA();</span><br><span class="line">        builder.buildPartB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 客户端代码</span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Builder builder = new ConcreteBuilder();</span><br><span class="line">        Director director = new Director(builder);</span><br><span class="line">        director.construct();</span><br><span class="line">        Product product = builder.getResult();</span><br><span class="line">        System.out.println(product);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1-4-工厂方法模式（Factory-Method-Pattern）"><a href="#1-4-工厂方法模式（Factory-Method-Pattern）" class="headerlink" title="1.4 工厂方法模式（Factory Method Pattern）"></a>1.4 工厂方法模式（Factory Method Pattern）</h4><p><strong>定义</strong>：定义一个创建对象的接口，但由子类决定实例化哪个类。</p>
<p><strong>原理</strong>：将对象的创建逻辑放在子类中，而不是在客户端代码中。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>  <strong>灵活性</strong>：可以在运行时决定创建对象的类型。</li>
<li>  <strong>符合开闭原则</strong>：对扩展开放，对修改关闭。</li>
</ul>
<p><strong>Java 示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// 产品接口</span><br><span class="line">public interface Product &#123;</span><br><span class="line">    void operation();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体产品A</span><br><span class="line">public class ConcreteProductA implements Product &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void operation() &#123;</span><br><span class="line">        System.out.println(&quot;ConcreteProductA operation&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体产品B</span><br><span class="line">public class ConcreteProductB implements Product &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void operation() &#123;</span><br><span class="line">        System.out.println(&quot;ConcreteProductB operation&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 工厂接口</span><br><span class="line">public abstract class Creator &#123;</span><br><span class="line">    public abstract Product factoryMethod();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体工厂A</span><br><span class="line">public class ConcreteCreatorA extends Creator &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Product factoryMethod() &#123;</span><br><span class="line">        return new ConcreteProductA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体工厂B</span><br><span class="line">public class ConcreteCreatorB extends Creator &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Product factoryMethod() &#123;</span><br><span class="line">        return new ConcreteProductB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 客户端代码</span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Creator creator = new ConcreteCreatorA();</span><br><span class="line">        Product product = creator.factoryMethod();</span><br><span class="line">        product.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1-5-抽象工厂模式（Abstract-Factory-Pattern）"><a href="#1-5-抽象工厂模式（Abstract-Factory-Pattern）" class="headerlink" title="1.5 抽象工厂模式（Abstract Factory Pattern）"></a>1.5 抽象工厂模式（Abstract Factory Pattern）</h4><p><strong>定义</strong>：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p>
<p><strong>原理</strong>：通过定义多个工厂接口，每个接口负责创建一组相关的对象。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>  <strong>一致性</strong>：确保创建的一系列对象具有一致性。</li>
<li>  <strong>扩展性</strong>：易于扩展产品系列，而不影响现有代码。</li>
</ul>
<p><strong>Java 示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">// 产品A接口</span><br><span class="line">public interface ProductA &#123;</span><br><span class="line">    void operationA();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 产品B接口</span><br><span class="line">public interface ProductB &#123;</span><br><span class="line">    void operationB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体产品A1</span><br><span class="line">public class ConcreteProductA1 implements ProductA &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void operationA() &#123;</span><br><span class="line">        System.out.println(&quot;ConcreteProductA1 operationA&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体产品B1</span><br><span class="line">public class ConcreteProductB1 implements ProductB &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void operationB() &#123;</span><br><span class="line">        System.out.println(&quot;ConcreteProductB1 operationB&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体产品A2</span><br><span class="line">public class ConcreteProductA2 implements ProductA &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void operationA() &#123;</span><br><span class="line">        System.out.println(&quot;ConcreteProductA2 operationA&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体产品B2</span><br><span class="line">public class ConcreteProductB2 implements ProductB &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void operationB() &#123;</span><br><span class="line">        System.out.println(&quot;ConcreteProductB2 operationB&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 抽象工厂接口</span><br><span class="line">public interface AbstractFactory &#123;</span><br><span class="line">    ProductA createProductA();</span><br><span class="line">    ProductB createProductB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体工厂1</span><br><span class="line">public class ConcreteFactory1 implements AbstractFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public ProductA createProductA() &#123;</span><br><span class="line">        return new ConcreteProductA1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public ProductB createProductB() &#123;</span><br><span class="line">        return new ConcreteProductB1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体工厂2</span><br><span class="line">public class ConcreteFactory2 implements AbstractFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public ProductA createProductA() &#123;</span><br><span class="line">        return new ConcreteProductA2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public ProductB createProductB() &#123;</span><br><span class="line">        return new ConcreteProductB2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 客户端代码</span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AbstractFactory factory = new ConcreteFactory1();</span><br><span class="line">        ProductA productA = factory.createProductA();</span><br><span class="line">        ProductB productB = factory.createProductB();</span><br><span class="line">        productA.operationA();</span><br><span class="line">        productB.operationB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="二、结构型模式（Structural-Patterns）"><a href="#二、结构型模式（Structural-Patterns）" class="headerlink" title="二、结构型模式（Structural Patterns）"></a>二、结构型模式（Structural Patterns）</h3><p>结构型模式关注如何将类或对象组合成更大的结构，以便更好地实现功能。</p>
<h4 id="2-1-适配器模式（Adapter-Pattern）"><a href="#2-1-适配器模式（Adapter-Pattern）" class="headerlink" title="2.1 适配器模式（Adapter Pattern）"></a>2.1 适配器模式（Adapter Pattern）</h4><p><strong>定义</strong>：将一个类的接口转换成客户希望的另一个接口。适配器模式使得原本接口不兼容的类可以合作。</p>
<p><strong>原理</strong>：通过引入一个适配器类，将目标接口转换为适配者接口。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>  <strong>接口兼容</strong>：使得接口不兼容的类可以协作。</li>
<li>  <strong>复用性</strong>：可以复用现有的类。</li>
</ul>
<p><strong>Java 示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 目标接口</span><br><span class="line">public interface Target &#123;</span><br><span class="line">    void request();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 适配者类</span><br><span class="line">public class Adaptee &#123;</span><br><span class="line">    public void specificRequest() &#123;</span><br><span class="line">        System.out.println(&quot;SpecificRequest&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 适配器类</span><br><span class="line">public class Adapter implements Target &#123;</span><br><span class="line">    private Adaptee adaptee;</span><br><span class="line"></span><br><span class="line">    public Adapter(Adaptee adaptee) &#123;</span><br><span class="line">        this.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void request() &#123;</span><br><span class="line">        adaptee.specificRequest();  // 适配方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 客户端代码</span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Adaptee adaptee = new Adaptee();</span><br><span class="line">        Target target = new Adapter(adaptee);</span><br><span class="line">        target.request();  // 通过适配器调用</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-2-桥接模式（Bridge-Pattern）"><a href="#2-2-桥接模式（Bridge-Pattern）" class="headerlink" title="2.2 桥接模式（Bridge Pattern）"></a>2.2 桥接模式（Bridge Pattern）</h4><p><strong>定义</strong>：将抽象部分与实现部分分离，使它们可以独立地变化。</p>
<p><strong>原理</strong>：通过定义抽象类和实现类，将它们的变化解耦。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>  <strong>解耦</strong>：抽象和实现的解耦，使得它们可以独立变化。</li>
<li>  <strong>灵活性</strong>：可以独立地扩展抽象和实现。</li>
</ul>
<p><strong>Java 示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">// 实现接口</span><br><span class="line">public interface Implementor &#123;</span><br><span class="line">    void operation();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体实现A</span><br><span class="line">public class ConcreteImplementorA implements Implementor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void operation() &#123;</span><br><span class="line">        System.out.println(&quot;ConcreteImplementorA operation&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体实现B</span><br><span class="line">public class ConcreteImplementorB implements Implementor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void operation() &#123;</span><br><span class="line">        System.out.println(&quot;ConcreteImplementorB operation&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 抽象类</span><br><span class="line">public abstract class Abstraction &#123;</span><br><span class="line">    protected Implementor implementor;</span><br><span class="line"></span><br><span class="line">    public Abstraction(Implementor implementor) &#123;</span><br><span class="line">        this.implementor = implementor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract void operation();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 扩展抽象类</span><br><span class="line">public class RefinedAbstraction extends Abstraction &#123;</span><br><span class="line">    public RefinedAbstraction(Implementor implementor) &#123;</span><br><span class="line">        super(implementor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void operation() &#123;</span><br><span class="line">        implementor.operation();  // 委托给实现类</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 客户端代码</span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Implementor implementorA = new ConcreteImplementorA();</span><br><span class="line">        Abstraction abstraction = new RefinedAbstraction(implementorA);</span><br><span class="line">        abstraction.operation();</span><br><span class="line"></span><br><span class="line">        Implementor implementorB = new ConcreteImplementorB();</span><br><span class="line">        abstraction = new RefinedAbstraction(implementorB);</span><br><span class="line">        abstraction.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-3-组合模式（Composite-Pattern）"><a href="#2-3-组合模式（Composite-Pattern）" class="headerlink" title="2.3 组合模式（Composite Pattern）"></a>2.3 组合模式（Composite Pattern）</h4><p><strong>定义</strong>：将对象组合成树形结构以表示部分 - 整体层次结构，使得客户端对单个对象和组合对象的使用具有一致性。</p>
<p><strong>原理</strong>：通过定义一个组件接口，将叶子节点和容器节点统一处理。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>  <strong>一致性</strong>：对单个对象和组合对象的一致性操作。</li>
<li>  <strong>简化客户端代码</strong>：客户端代码可以统一处理叶子节点和容器节点。</li>
</ul>
<p><strong>Java 示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">// 组件接口</span><br><span class="line">public interface Component &#123;</span><br><span class="line">    void operation();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 叶子节点</span><br><span class="line">public class Leaf implements Component &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void operation() &#123;</span><br><span class="line">        System.out.println(&quot;Leaf operation&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 容器节点</span><br><span class="line">public class Composite implements Component &#123;</span><br><span class="line">    private List&lt;Component&gt; children = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public void add(Component component) &#123;</span><br><span class="line">        children.add(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void remove(Component component) &#123;</span><br><span class="line">        children.remove(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void operation() &#123;</span><br><span class="line">        for (Component child : children) &#123;</span><br><span class="line">            child.operation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 客户端代码</span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Composite root = new Composite();</span><br><span class="line">        Component leaf1 = new Leaf();</span><br><span class="line">        Component leaf2 = new Leaf();</span><br><span class="line"></span><br><span class="line">        root.add(leaf1);</span><br><span class="line">        root.add(leaf2);</span><br><span class="line"></span><br><span class="line">        root.operation();  // 统一调用</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-4-装饰器模式（Decorator-Pattern）"><a href="#2-4-装饰器模式（Decorator-Pattern）" class="headerlink" title="2.4 装饰器模式（Decorator Pattern）"></a>2.4 装饰器模式（Decorator Pattern）</h4><p><strong>定义</strong>：动态地给一个对象添加一些额外的职责。装饰器模式提供了比继承更灵活的扩展功能的方式。</p>
<p><strong>原理</strong>：通过定义装饰器类来扩展被装饰对象的功能。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>  <strong>灵活性</strong>：可以动态地扩展对象的功能。</li>
<li>  <strong>避免子类爆炸</strong>：通过装饰器而不是继承来扩展功能。</li>
</ul>
<p><strong>Java 示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">// 组件接口</span><br><span class="line">public interface Component &#123;</span><br><span class="line">    void operation();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体组件</span><br><span class="line">public class ConcreteComponent implements Component &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void operation() &#123;</span><br><span class="line">        System.out.println(&quot;ConcreteComponent operation&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 装饰器抽象类</span><br><span class="line">public abstract class Decorator implements Component &#123;</span><br><span class="line">    protected Component component;</span><br><span class="line"></span><br><span class="line">    public Decorator(Component component) &#123;</span><br><span class="line">        this.component = component;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void operation() &#123;</span><br><span class="line">        component.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体装饰器</span><br><span class="line">public class ConcreteDecorator extends Decorator &#123;</span><br><span class="line">    public ConcreteDecorator(Component component) &#123;</span><br><span class="line">        super(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void operation() &#123;</span><br><span class="line">        super.operation();</span><br><span class="line">        addedBehavior();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void addedBehavior() &#123;</span><br><span class="line">        System.out.println(&quot;ConcreteDecorator addedBehavior&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 客户端代码</span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Component component = new ConcreteComponent();</span><br><span class="line">        Component decorator = new ConcreteDecorator(component);</span><br><span class="line">        decorator.operation();  // 执行装饰后的操作</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-5-外观模式（Facade-Pattern）"><a href="#2-5-外观模式（Facade-Pattern）" class="headerlink" title="2.5 外观模式（Facade Pattern）"></a>2.5 外观模式（Facade Pattern）</h4><p><strong>定义</strong>：为子系统中的一组接口提供一个一致的界面，使得子系统更容易使用。</p>
<p><strong>原理</strong>：通过定义一个外观类来封装子系统的复杂性，提供简化的接口。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>  <strong>简化使用</strong>：提供简单的接口来访问复杂的子系统。</li>
<li>  <strong>解耦</strong>：将客户端与子系统解耦。</li>
</ul>
<p><strong>Java 示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// 子系统类A</span><br><span class="line">public class SubsystemA &#123;</span><br><span class="line">    public void operationA() &#123;</span><br><span class="line">        System.out.println(&quot;SubsystemA operationA&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 子系统类B</span><br><span class="line">public class SubsystemB &#123;</span><br><span class="line">    public void operationB() &#123;</span><br><span class="line">        System.out.println(&quot;SubsystemB operationB&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 外观类</span><br><span class="line">public class Facade &#123;</span><br><span class="line">    private SubsystemA subsystemA;</span><br><span class="line">    private SubsystemB subsystemB;</span><br><span class="line"></span><br><span class="line">    public Facade() &#123;</span><br><span class="line">        subsystemA = new SubsystemA();</span><br><span class="line">        subsystemB = new SubsystemB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void operation() &#123;</span><br><span class="line">        subsystemA.operationA();</span><br><span class="line">        subsystemB.operationB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 客户端代码</span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Facade facade = new Facade();</span><br><span class="line">        facade.operation();  // 通过外观类调用子系统</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-6-享元模式（Flyweight-Pattern）"><a href="#2-6-享元模式（Flyweight-Pattern）" class="headerlink" title="2.6 享元模式（Flyweight Pattern）"></a>2.6 享元模式（Flyweight Pattern）</h4><p><strong>定义</strong>：运用共享技术有效地支持大量细粒度的对象。</p>
<p><strong>原理</strong>：通过将对象的共享部分与独享部分分开，将共享部分提取出来。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>  <strong>节省内存</strong>：通过共享来减少内存使用。</li>
<li>  <strong>提高性能</strong>：减少对象创建和管理的开销。</li>
</ul>
<p><strong>Java 示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">// 享元接口</span><br><span class="line">public interface</span><br><span class="line"></span><br><span class="line"> Flyweight &#123;</span><br><span class="line">    void operation(String extrinsicState);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体享元类</span><br><span class="line">public class ConcreteFlyweight implements Flyweight &#123;</span><br><span class="line">    private String intrinsicState;</span><br><span class="line"></span><br><span class="line">    public ConcreteFlyweight(String intrinsicState) &#123;</span><br><span class="line">        this.intrinsicState = intrinsicState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void operation(String extrinsicState) &#123;</span><br><span class="line">        System.out.println(&quot;Intrinsic State: &quot; + intrinsicState + &quot;, Extrinsic State: &quot; + extrinsicState);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 享元工厂</span><br><span class="line">public class FlyweightFactory &#123;</span><br><span class="line">    private Map&lt;String, Flyweight&gt; flyweights = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public Flyweight getFlyweight(String key) &#123;</span><br><span class="line">        Flyweight flyweight = flyweights.get(key);</span><br><span class="line">        if (flyweight == null) &#123;</span><br><span class="line">            flyweight = new ConcreteFlyweight(key);</span><br><span class="line">            flyweights.put(key, flyweight);</span><br><span class="line">        &#125;</span><br><span class="line">        return flyweight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 客户端代码</span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        FlyweightFactory factory = new FlyweightFactory();</span><br><span class="line">        Flyweight flyweight1 = factory.getFlyweight(&quot;A&quot;);</span><br><span class="line">        Flyweight flyweight2 = factory.getFlyweight(&quot;B&quot;);</span><br><span class="line">        flyweight1.operation(&quot;1&quot;);</span><br><span class="line">        flyweight2.operation(&quot;2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-7-代理模式（Proxy-Pattern）"><a href="#2-7-代理模式（Proxy-Pattern）" class="headerlink" title="2.7 代理模式（Proxy Pattern）"></a>2.7 代理模式（Proxy Pattern）</h4><p><strong>定义</strong>：为其他对象提供一种代理以控制对这个对象的访问。</p>
<p><strong>原理</strong>：通过定义代理类来控制对真实对象的访问。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>  <strong>控制访问</strong>：可以在代理中实现对真实对象的控制。</li>
<li>  <strong>增强功能</strong>：可以在代理中增加额外的功能，如延迟加载。</li>
</ul>
<p><strong>Java 示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 抽象主题接口</span><br><span class="line">public interface Subject &#123;</span><br><span class="line">    void request();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 真实主题类</span><br><span class="line">public class RealSubject implements Subject &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void request() &#123;</span><br><span class="line">        System.out.println(&quot;RealSubject request&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 代理类</span><br><span class="line">public class Proxy implements Subject &#123;</span><br><span class="line">    private RealSubject realSubject;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void request() &#123;</span><br><span class="line">        if (realSubject == null) &#123;</span><br><span class="line">            realSubject = new RealSubject();</span><br><span class="line">        &#125;</span><br><span class="line">        realSubject.request();  // 代理控制对真实主题的访问</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 客户端代码</span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Subject proxy = new Proxy();</span><br><span class="line">        proxy.request();  // 通过代理访问真实主题</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="三、行为型模式（Behavioral-Patterns）"><a href="#三、行为型模式（Behavioral-Patterns）" class="headerlink" title="三、行为型模式（Behavioral Patterns）"></a>三、行为型模式（Behavioral Patterns）</h3><p>行为型模式关注对象之间的沟通和职责分配。</p>
<h4 id="3-1-责任链模式（Chain-of-Responsibility-Pattern）"><a href="#3-1-责任链模式（Chain-of-Responsibility-Pattern）" class="headerlink" title="3.1 责任链模式（Chain of Responsibility Pattern）"></a>3.1 责任链模式（Chain of Responsibility Pattern）</h4><p><strong>定义</strong>：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止。</p>
<p><strong>原理</strong>：通过定义处理请求的链，并逐步将请求传递给链中的各个对象，直到找到合适的处理者。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>  <strong>解耦</strong>：发送者和接收者解耦。</li>
<li>  <strong>灵活性</strong>：可以动态地添加或修改处理者。</li>
</ul>
<p><strong>Java 示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// 处理者接口</span><br><span class="line">public abstract class Handler &#123;</span><br><span class="line">    protected Handler nextHandler;</span><br><span class="line"></span><br><span class="line">    public void setNextHandler(Handler nextHandler) &#123;</span><br><span class="line">        this.nextHandler = nextHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract void handleRequest(String request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体处理者A</span><br><span class="line">public class ConcreteHandlerA extends Handler &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void handleRequest(String request) &#123;</span><br><span class="line">        if (request.equals(&quot;A&quot;)) &#123;</span><br><span class="line">            System.out.println(&quot;Handler A handling request A&quot;);</span><br><span class="line">        &#125; else if (nextHandler != null) &#123;</span><br><span class="line">            nextHandler.handleRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体处理者B</span><br><span class="line">public class ConcreteHandlerB extends Handler &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void handleRequest(String request) &#123;</span><br><span class="line">        if (request.equals(&quot;B&quot;)) &#123;</span><br><span class="line">            System.out.println(&quot;Handler B handling request B&quot;);</span><br><span class="line">        &#125; else if (nextHandler != null) &#123;</span><br><span class="line">            nextHandler.handleRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 客户端代码</span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Handler handlerA = new ConcreteHandlerA();</span><br><span class="line">        Handler handlerB = new ConcreteHandlerB();</span><br><span class="line">        handlerA.setNextHandler(handlerB);</span><br><span class="line"></span><br><span class="line">        handlerA.handleRequest(&quot;A&quot;);  // 处理请求A</span><br><span class="line">        handlerA.handleRequest(&quot;B&quot;);  // 处理请求B</span><br><span class="line">        handlerA.handleRequest(&quot;C&quot;);  // 无处理者</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-2-命令模式（Command-Pattern）"><a href="#3-2-命令模式（Command-Pattern）" class="headerlink" title="3.2 命令模式（Command Pattern）"></a>3.2 命令模式（Command Pattern）</h4><p><strong>定义</strong>：将请求封装成一个对象，从而使你能够用不同的请求对客户进行参数化、队列化请求、以及支持可撤销操作。</p>
<p><strong>原理</strong>：通过定义命令接口和具体命令类，将请求封装为对象，并将其传递给调用者。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>  <strong>解耦</strong>：发送者和接收者解耦。</li>
<li>  <strong>灵活性</strong>：可以动态地创建、撤销请求。</li>
</ul>
<p><strong>Java 示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">// 命令接口</span><br><span class="line">public interface Command &#123;</span><br><span class="line">    void execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体命令类</span><br><span class="line">public class ConcreteCommand implements Command &#123;</span><br><span class="line">    private Receiver receiver;</span><br><span class="line"></span><br><span class="line">    public ConcreteCommand(Receiver receiver) &#123;</span><br><span class="line">        this.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void execute() &#123;</span><br><span class="line">        receiver.action();  // 将请求委托给接收者</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 接收者类</span><br><span class="line">public class Receiver &#123;</span><br><span class="line">    public void action() &#123;</span><br><span class="line">        System.out.println(&quot;Receiver action&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用者类</span><br><span class="line">public class Invoker &#123;</span><br><span class="line">    private Command command;</span><br><span class="line"></span><br><span class="line">    public void setCommand(Command command) &#123;</span><br><span class="line">        this.command = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void invoke() &#123;</span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 客户端代码</span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Receiver receiver = new Receiver();</span><br><span class="line">        Command command = new ConcreteCommand(receiver);</span><br><span class="line">        Invoker invoker = new Invoker();</span><br><span class="line">        invoker.setCommand(command);</span><br><span class="line">        invoker.invoke();  // 执行命令</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-3-迭代器模式（Iterator-Pattern）"><a href="#3-3-迭代器模式（Iterator-Pattern）" class="headerlink" title="3.3 迭代器模式（Iterator Pattern）"></a>3.3 迭代器模式（Iterator Pattern）</h4><p><strong>定义</strong>：提供一种方法访问一个容器对象中各个元素，而又不暴露该对象的内部表示。</p>
<p><strong>原理</strong>：通过定义迭代器接口和具体迭代器类来遍历集合对象中的元素。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>  <strong>简化访问</strong>：提供统一的访问方式。</li>
<li>  <strong>解耦</strong>：容器和迭代器解耦。</li>
</ul>
<p><strong>Java 示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">// 迭代器接口</span><br><span class="line">public interface Iterator &#123;</span><br><span class="line">    boolean hasNext();</span><br><span class="line">    Object next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体迭代器类</span><br><span class="line">public class ConcreteIterator implements Iterator &#123;</span><br><span class="line">    private List&lt;Object&gt; items;</span><br><span class="line">    private int position;</span><br><span class="line"></span><br><span class="line">    public ConcreteIterator(List&lt;Object&gt; items) &#123;</span><br><span class="line">        this.items = items;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean hasNext() &#123;</span><br><span class="line">        return position &lt; items.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object next() &#123;</span><br><span class="line">        return items.get(position++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 聚合类</span><br><span class="line">public class Aggregate &#123;</span><br><span class="line">    private List&lt;Object&gt; items = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public void add(Object item) &#123;</span><br><span class="line">        items.add(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Iterator iterator() &#123;</span><br><span class="line">        return new ConcreteIterator(items);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 客户端代码</span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Aggregate aggregate = new Aggregate();</span><br><span class="line">        aggregate.add(&quot;Item 1&quot;);</span><br><span class="line">        aggregate.add(&quot;Item 2&quot;);</span><br><span class="line"></span><br><span class="line">        Iterator iterator = aggregate.iterator();</span><br><span class="line">        while (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-4-中介者模式（Mediator-Pattern）"><a href="#3-4-中介者模式（Mediator-Pattern）" class="headerlink" title="3.4 中介者模式（Mediator Pattern）"></a>3.4 中介者模式（Mediator Pattern）</h4><p><strong>定义</strong>：定义一个对象来封装一组对象之间的交互，使得对象之间的耦合松散，从而使得它们可以独立地改变。</p>
<p><strong>原理</strong>：通过定义中介者接口和具体中介者类来协调对象之间的交互。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>  <strong>降低耦合</strong>：将对象间的交互集中在中介者中。</li>
<li>  <strong>易于维护</strong>：中介者可以集中处理复杂的交互逻辑。</li>
</ul>
<p><strong>Java 示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">// 中介者接口</span><br><span class="line">public interface Mediator &#123;</span><br><span class="line">    void notify(Component sender, String event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体中介者类</span><br><span class="line">public class ConcreteMediator implements Mediator &#123;</span><br><span class="line">    private ComponentA componentA;</span><br><span class="line">    private ComponentB componentB;</span><br><span class="line"></span><br><span class="line">    public void setComponentA(ComponentA componentA) &#123;</span><br><span class="line">        this.componentA = componentA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setComponentB(ComponentB componentB) &#123;</span><br><span class="line">        this.componentB = componentB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void notify(Component sender, String event) &#123;</span><br><span class="line">        if (sender == componentA) &#123;</span><br><span class="line">            componentB.handleEvent(event);</span><br><span class="line">        &#125; else if (sender == componentB) &#123;</span><br><span class="line">            componentA.handleEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 组件接口</span><br><span class="line">public abstract class Component &#123;</span><br><span class="line">    protected Mediator mediator;</span><br><span class="line"></span><br><span class="line">    public Component(Mediator mediator) &#123;</span><br><span class="line">        this.mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract void handleEvent(String event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体组件A</span><br><span class="line">public class ComponentA extends Component &#123;</span><br><span class="line">    public ComponentA(Mediator mediator) &#123;</span><br><span class="line">        super(mediator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void handleEvent(String event) &#123;</span><br><span class="line">        System.out.println(&quot;ComponentA handling event: &quot;</span><br><span class="line"></span><br><span class="line"> + event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void triggerEvent(String event) &#123;</span><br><span class="line">        mediator.notify(this, event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体组件B</span><br><span class="line">public class ComponentB extends Component &#123;</span><br><span class="line">    public ComponentB(Mediator mediator) &#123;</span><br><span class="line">        super(mediator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void handleEvent(String event) &#123;</span><br><span class="line">        System.out.println(&quot;ComponentB handling event: &quot; + event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 客户端代码</span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ConcreteMediator mediator = new ConcreteMediator();</span><br><span class="line">        ComponentA componentA = new ComponentA(mediator);</span><br><span class="line">        ComponentB componentB = new ComponentB(mediator);</span><br><span class="line">        mediator.setComponentA(componentA);</span><br><span class="line">        mediator.setComponentB(componentB);</span><br><span class="line"></span><br><span class="line">        componentA.triggerEvent(&quot;Event A&quot;);</span><br><span class="line">        componentB.handleEvent(&quot;Event B&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-5-备忘录模式（Memento-Pattern）"><a href="#3-5-备忘录模式（Memento-Pattern）" class="headerlink" title="3.5 备忘录模式（Memento Pattern）"></a>3.5 备忘录模式（Memento Pattern）</h4><p><strong>定义</strong>：在不暴露对象内部状态的情况下，捕获一个对象的内部状态，并在该对象外部保存这个状态。可以在以后将对象恢复到保存的状态。</p>
<p><strong>原理</strong>：通过定义备忘录类来保存对象的状态，并通过发起人类和恢复者类来实现状态的恢复。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>  <strong>状态恢复</strong>：可以在需要的时候恢复对象的状态。</li>
<li>  <strong>封装性</strong>：不暴露对象的内部状态。</li>
</ul>
<p><strong>Java 示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">// 备忘录类</span><br><span class="line">public class Memento &#123;</span><br><span class="line">    private String state;</span><br><span class="line"></span><br><span class="line">    public Memento(String state) &#123;</span><br><span class="line">        this.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getState() &#123;</span><br><span class="line">        return state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 发起人类</span><br><span class="line">public class Originator &#123;</span><br><span class="line">    private String state;</span><br><span class="line"></span><br><span class="line">    public void setState(String state) &#123;</span><br><span class="line">        this.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getState() &#123;</span><br><span class="line">        return state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Memento saveStateToMemento() &#123;</span><br><span class="line">        return new Memento(state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void getStateFromMemento(Memento memento) &#123;</span><br><span class="line">        state = memento.getState();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 管理者类</span><br><span class="line">public class Caretaker &#123;</span><br><span class="line">    private Memento memento;</span><br><span class="line"></span><br><span class="line">    public void saveMemento(Memento memento) &#123;</span><br><span class="line">        this.memento = memento;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Memento retrieveMemento() &#123;</span><br><span class="line">        return memento;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 客户端代码</span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Originator originator = new Originator();</span><br><span class="line">        Caretaker caretaker = new Caretaker();</span><br><span class="line"></span><br><span class="line">        originator.setState(&quot;State1&quot;);</span><br><span class="line">        caretaker.saveMemento(originator.saveStateToMemento());</span><br><span class="line"></span><br><span class="line">        originator.setState(&quot;State2&quot;);</span><br><span class="line">        System.out.println(&quot;Current State: &quot; + originator.getState());</span><br><span class="line"></span><br><span class="line">        originator.getStateFromMemento(caretaker.retrieveMemento());</span><br><span class="line">        System.out.println(&quot;Restored State: &quot; + originator.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-6-解释器模式（Interpreter-Pattern）"><a href="#3-6-解释器模式（Interpreter-Pattern）" class="headerlink" title="3.6 解释器模式（Interpreter Pattern）"></a>3.6 解释器模式（Interpreter Pattern）</h4><p><strong>定义</strong>：给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。</p>
<p><strong>原理</strong>：通过定义解释器类和表达式类，将文法规则和解释逻辑分开。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>  <strong>易于扩展</strong>：可以通过增加新的终结符和非终结符来扩展语法。</li>
<li>  <strong>灵活性</strong>：可以定义复杂的语言规则。</li>
</ul>
<p><strong>Java 示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">// 表达式接口</span><br><span class="line">public interface Expression &#123;</span><br><span class="line">    int interpret(Map&lt;String, Integer&gt; context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 终结符表达式</span><br><span class="line">public class NumberExpression implements Expression &#123;</span><br><span class="line">    private int number;</span><br><span class="line"></span><br><span class="line">    public NumberExpression(int number) &#123;</span><br><span class="line">        this.number = number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int interpret(Map&lt;String, Integer&gt; context) &#123;</span><br><span class="line">        return number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 非终结符表达式</span><br><span class="line">public class PlusExpression implements Expression &#123;</span><br><span class="line">    private Expression left;</span><br><span class="line">    private Expression right;</span><br><span class="line"></span><br><span class="line">    public PlusExpression(Expression left, Expression right) &#123;</span><br><span class="line">        this.left = left;</span><br><span class="line">        this.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int interpret(Map&lt;String, Integer&gt; context) &#123;</span><br><span class="line">        return left.interpret(context) + right.interpret(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 客户端代码</span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Expression expression = new PlusExpression(new NumberExpression(5), new NumberExpression(3));</span><br><span class="line">        Map&lt;String, Integer&gt; context = new HashMap&lt;&gt;();</span><br><span class="line">        int result = expression.interpret(context);</span><br><span class="line">        System.out.println(&quot;Result: &quot; + result);  // 输出结果 8</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-7-状态模式（State-Pattern）"><a href="#3-7-状态模式（State-Pattern）" class="headerlink" title="3.7 状态模式（State Pattern）"></a>3.7 状态模式（State Pattern）</h4><p><strong>定义</strong>：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。</p>
<p><strong>原理</strong>：通过定义状态接口和具体状态类，将对象的状态和行为分开，使得状态改变时可以改变行为。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>  <strong>状态独立</strong>：每个状态都有自己的行为。</li>
<li>  <strong>易于扩展</strong>：可以增加新的状态而不改变现有代码。</li>
</ul>
<p><strong>Java 示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">// 状态接口</span><br><span class="line">public interface State &#123;</span><br><span class="line">    void handle(Context context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体状态A</span><br><span class="line">public class ConcreteStateA implements State &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void handle(Context context) &#123;</span><br><span class="line">        System.out.println(&quot;Handling state A&quot;);</span><br><span class="line">        context.setState(new ConcreteStateB());  // 切换到状态B</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体状态B</span><br><span class="line">public class ConcreteStateB implements State &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void handle(Context context) &#123;</span><br><span class="line">        System.out.println(&quot;Handling state B&quot;);</span><br><span class="line">        context.setState(new ConcreteStateA());  // 切换到状态A</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 上下文类</span><br><span class="line">public class Context &#123;</span><br><span class="line">    private State state;</span><br><span class="line"></span><br><span class="line">    public Context(State state) &#123;</span><br><span class="line">        this.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setState(State state) &#123;</span><br><span class="line">        this.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void request() &#123;</span><br><span class="line">        state.handle(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 客户端代码</span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Context context = new Context(new ConcreteStateA());</span><br><span class="line">        context.request();  // 处理状态A</span><br><span class="line">        context.request();  // 处理状态B</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-8-策略模式（Strategy-Pattern）"><a href="#3-8-策略模式（Strategy-Pattern）" class="headerlink" title="3.8 策略模式（Strategy Pattern）"></a>3.8 策略模式（Strategy Pattern）</h4><p><strong>定义</strong>：定义一系列算法，将每一个算法封装起来，并使它们可以相互替换。策略模式让算法独立于使用它的客户而独立变化。</p>
<p><strong>原理</strong>：通过定义策略接口和具体策略类，将算法封装为对象，并在运行时选择使用。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>  <strong>灵活性</strong>：可以动态选择算法。</li>
<li>  <strong>易于扩展</strong>：可以新增策略而不影响现有代码。</li>
</ul>
<p><strong>Java 示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">// 策略接口</span><br><span class="line">public interface Strategy &#123;</span><br><span class="line">    void execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体策略A</span><br><span class="line">public class ConcreteStrategyA implements Strategy &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void execute() &#123;</span><br><span class="line">        System.out.println(&quot;Executing strategy A&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体策略B</span><br><span class="line">public class ConcreteStrategyB implements Strategy &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void execute() &#123;</span><br><span class="line">        System.out.println(&quot;Executing strategy B&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 上下文类</span><br><span class="line">public class Context &#123;</span><br><span class="line">    private Strategy strategy;</span><br><span class="line"></span><br><span class="line">    public void setStrategy(Strategy strategy) &#123;</span><br><span class="line">        this.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void executeStrategy() &#123;</span><br><span class="line">        strategy.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 客户端代码</span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Context context = new Context();</span><br><span class="line">        context.setStrategy(new ConcreteStrategyA());</span><br><span class="line">        context.executeStrategy();  // 执行策略A</span><br><span class="line"></span><br><span class="line">        context.setStrategy(new ConcreteStrategyB());</span><br><span class="line">        context.executeStrategy();  // 执行策略B</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-9-模板方法模式（Template-Method-Pattern）"><a href="#3-9-模板方法模式（Template-Method-Pattern）" class="headerlink" title="3.9 模板方法模式（Template Method Pattern）"></a>3.9 模板方法模式（Template Method Pattern）</h4><p><strong>定义</strong>：定义一个操作中的算法的骨架，将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下重新定义算法中的某些步骤。</p>
<p><strong>原理</strong>：通过定义模板方法在父类中，并将一些步骤的实现延迟到子类中。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>  <strong>复用性</strong>：将公共算法逻辑放在父类中。</li>
<li>  <strong>灵活性</strong>：子类可以改变某些步骤的实现而不改变算法结构。</li>
</ul>
<p><strong>Java 示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">// 抽象类</span><br><span class="line">public abstract class AbstractClass &#123;</span><br><span class="line">    // 模板方法</span><br><span class="line">    public final void templateMethod() &#123;</span><br><span class="line">        step1();</span><br><span class="line">        step2();</span><br><span class="line">        step3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 具体步骤1</span><br><span class="line">    private void step1() &#123;</span><br><span class="line">        System.out.println(&quot;Step 1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 具体步骤2，留给子类实现</span><br><span class="line">    protected abstract void step2();</span><br><span class="line"></span><br><span class="line">    // 具体步骤3</span><br><span class="line">    private void step3() &#123;</span><br><span class="line">        System.out.println(&quot;Step 3&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体类A</span><br><span class="line">public class ConcreteClassA extends AbstractClass &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void step2() &#123;</span><br><span class="line">        System.out.println(&quot;ConcreteClassA Step 2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体类B</span><br><span class="line">public class ConcreteClassB extends AbstractClass &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void step2() &#123;</span><br><span class="line">        System.out.println(&quot;ConcreteClassB Step 2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 客户端代码</span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AbstractClass concreteClassA = new ConcreteClassA();</span><br><span class="line">        concreteClass</span><br><span class="line"></span><br><span class="line">A.templateMethod();  // 执行具体类A的模板方法</span><br><span class="line"></span><br><span class="line">        AbstractClass concreteClassB = new ConcreteClassB();</span><br><span class="line">        concreteClassB.templateMethod();  // 执行具体类B的模板方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-10-访问者模式（Visitor-Pattern）"><a href="#3-10-访问者模式（Visitor-Pattern）" class="headerlink" title="3.10 访问者模式（Visitor Pattern）"></a>3.10 访问者模式（Visitor Pattern）</h4><p><strong>定义</strong>：表示一个作用于某对象结构中的各元素的操作，它可以在不改变元素类的前提下定义作用于这些元素的新操作。</p>
<p><strong>原理</strong>：通过定义访问者接口和具体访问者类，将操作和对象结构分离，使得可以在不改变对象结构的情况下增加新的操作。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>  <strong>扩展性</strong>：可以在不改变对象结构的情况下增加新的操作。</li>
<li>  <strong>操作集中</strong>：操作被集中在访问者中，使得相关操作更易于维护。</li>
</ul>
<p><strong>Java 示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">// 访问者接口</span><br><span class="line">public interface Visitor &#123;</span><br><span class="line">    void visit(ConcreteElementA elementA);</span><br><span class="line">    void visit(ConcreteElementB elementB);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体访问者A</span><br><span class="line">public class ConcreteVisitorA implements Visitor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void visit(ConcreteElementA elementA) &#123;</span><br><span class="line">        System.out.println(&quot;Visitor A visiting Element A&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void visit(ConcreteElementB elementB) &#123;</span><br><span class="line">        System.out.println(&quot;Visitor A visiting Element B&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体访问者B</span><br><span class="line">public class ConcreteVisitorB implements Visitor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void visit(ConcreteElementA elementA) &#123;</span><br><span class="line">        System.out.println(&quot;Visitor B visiting Element A&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void visit(ConcreteElementB elementB) &#123;</span><br><span class="line">        System.out.println(&quot;Visitor B visiting Element B&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 元素接口</span><br><span class="line">public interface Element &#123;</span><br><span class="line">    void accept(Visitor visitor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体元素A</span><br><span class="line">public class ConcreteElementA implements Element &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(Visitor visitor) &#123;</span><br><span class="line">        visitor.visit(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体元素B</span><br><span class="line">public class ConcreteElementB implements Element &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(Visitor visitor) &#123;</span><br><span class="line">        visitor.visit(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 对象结构</span><br><span class="line">public class ObjectStructure &#123;</span><br><span class="line">    private List&lt;Element&gt; elements = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public void addElement(Element element) &#123;</span><br><span class="line">        elements.add(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void accept(Visitor visitor) &#123;</span><br><span class="line">        for (Element element : elements) &#123;</span><br><span class="line">            element.accept(visitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 客户端代码</span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ObjectStructure structure = new ObjectStructure();</span><br><span class="line">        structure.addElement(new ConcreteElementA());</span><br><span class="line">        structure.addElement(new ConcreteElementB());</span><br><span class="line"></span><br><span class="line">        Visitor visitorA = new ConcreteVisitorA();</span><br><span class="line">        structure.accept(visitorA);  // Visitor A visiting elements</span><br><span class="line"></span><br><span class="line">        Visitor visitorB = new ConcreteVisitorB();</span><br><span class="line">        structure.accept(visitorB);  // Visitor B visiting elements</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-11-观察者模式（Observer-Pattern）"><a href="#3-11-观察者模式（Observer-Pattern）" class="headerlink" title="3.11 观察者模式（Observer Pattern）"></a>3.11 观察者模式（Observer Pattern）</h4><p><strong>定义</strong>：定义对象之间的一对多依赖，使得当一个对象改变状态时，所有依赖于它的对象都得到通知并被自动更新。</p>
<p><strong>原理</strong>：通过定义观察者接口和被观察者类来实现一对多的通知机制。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>  <strong>解耦</strong>：观察者和被观察者之间的解耦。</li>
<li>  <strong>动态更新</strong>：自动更新所有观察者。</li>
</ul>
<p><strong>Java 示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import</span><br><span class="line"></span><br><span class="line"> java.util.List;</span><br><span class="line"></span><br><span class="line">// 观察者接口</span><br><span class="line">public interface Observer &#123;</span><br><span class="line">    void update(String message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 被观察者接口</span><br><span class="line">public interface Subject &#123;</span><br><span class="line">    void addObserver(Observer observer);</span><br><span class="line">    void removeObserver(Observer observer);</span><br><span class="line">    void notifyObservers(String message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体被观察者</span><br><span class="line">public class ConcreteSubject implements Subject &#123;</span><br><span class="line">    private List&lt;Observer&gt; observers = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addObserver(Observer observer) &#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void removeObserver(Observer observer) &#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void notifyObservers(String message) &#123;</span><br><span class="line">        for (Observer observer : observers) &#123;</span><br><span class="line">            observer.update(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体观察者</span><br><span class="line">public class ConcreteObserver implements Observer &#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public ConcreteObserver(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void update(String message) &#123;</span><br><span class="line">        System.out.println(name + &quot; received: &quot; + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 客户端代码</span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ConcreteSubject subject = new ConcreteSubject();</span><br><span class="line">        Observer observer1 = new ConcreteObserver(&quot;Observer1&quot;);</span><br><span class="line">        Observer observer2 = new ConcreteObserver(&quot;Observer2&quot;);</span><br><span class="line">        subject.addObserver(observer1);</span><br><span class="line">        subject.addObserver(observer2);</span><br><span class="line"></span><br><span class="line">        subject.notifyObservers(&quot;Hello Observers!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这些设计模式是解决常见设计问题的通用方案。每种模式都有其独特的应用场景和优点，通过合理运用这些模式，可以使软件系统更加灵活、可维护和可扩展。</p>



<div class="article-footer reveal fs14"><section id="share"><div class="header"><span>分享文章</span></div><div class="body"><div class="link"><input class="copy-area" readonly="true" id="copy-link" value="https://su3.cn/2024/08/02/2024080201/" /></div><div class="social-wrap dis-select"><a class="social share-item wechat" onclick="util.toggle(&quot;qrcode-wechat&quot)"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/social/b32ef3da1162a.svg"/></a><a class="social share-item weibo" target="_blank" rel="external nofollow noopener noreferrer" href="https://service.weibo.com/share/share.php?url=https://su3.cn/2024/08/02/2024080201/&title=Java 中常用的 23 种设计模式详解1 - 苏三博客&summary=Java 中常用的 23 种设计模式详解"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/social/80c07e4dbb303.svg"/></a><a class="social share-item email" href="mailto:?subject=Java 中常用的 23 种设计模式详解1 - 苏三博客&amp;body=https://su3.cn/2024/08/02/2024080201/"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/social/a1b00e20f425d.svg"/></a><a class="social share-item link" onclick="util.copy(&quot;copy-link&quot;, &quot;复制成功&quot;)"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/social/8411ed322ced6.svg"/></a></div><div class="qrcode" id="qrcode-wechat" style="visibility:hidden;height:0"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://api.qrserver.com/v1/create-qr-code/?size=256x256&data=https://su3.cn/2024/08/02/2024080201/"/></div></div></section></div>

</article>

<div class="related-wrap reveal" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/2024/08/02/2024080203/">java 中的 dto、dao、vo、bo、do、po、pojo_dto dao区别</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/2024/08/02/2024080202/">Java 中常用的 23 种设计模式详解2</a></div></section></div>






  <div class='related-wrap md-text reveal' id="comments">
    <section class='header cmt-title cap theme'>
      快来参与讨论吧
    </section>
    <section class='body cmt-body giscus'>
      

<svg class="loading" style="vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2709"><path d="M832 512c0-176-144-320-320-320V128c211.2 0 384 172.8 384 384h-64zM192 512c0 176 144 320 320 320v64C300.8 896 128 723.2 128 512h64z" p-id="2710"></path></svg>

<div id="giscus" data-repo="zhhltc/blogcomments" data-repo-id="R_kgDOI35Puw" data-category="Announcements" data-category-id="DIC_kwDOI35Pu84CT54y" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="preferred_color_scheme" data-lang="zh-CN" data-loading="lazy" crossorigin="anonymous"></div>

    </section>
  </div>



      
<footer class="page-footer reveal fs12"><hr><div class="text"><div class="BeiAn-info" style="display: flex;text-align: center;margin:10px;justify-content: center; align-items: center;"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/p/imgs/beian.png" title="备案管理系统" style="width:15px;height:15px;"> <a href="http://beian.miit.gov.cn/" style="text-decoration:none;" target=_blank title=备案号>赣ICP备17016237号-1</a></div><div  style="display: flex;text-align: center;justify-content: center; align-items: center;"><span id="timeDate">载入天数...</span>|<span id="times">载入时分秒...</span><span class="post-meta-divider">|</span><span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span><span class="post-meta-divider">|</span><span id="busuanzi_container_site_uv" style="display:none">本站访客数<span id="busuanzi_value_site_uv"></span>人</span></div><script type="text/javascript" src="/js/jquery-3.5.1.min.js"></script><script type="text/javascript" src="/js/dist/zoomify.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></footer>

<!--添加网站运行时间 -->
<!--<br/>-->

<script>
    var now = new Date();

    function createtime() {
        var grt = new Date("11/01/2021 12:00:00");
        now.setTime(now.getTime() + 250);
        days = (now - grt) / 1000 / 60 / 60 / 24;
        dnum = Math.floor(days);
        hours = (now - grt) / 1000 / 60 / 60 - (24 * dnum);
        hnum = Math.floor(hours);
        if (String(hnum).length == 1) {
            hnum = "0" + hnum;
        }
        minutes = (now - grt) / 1000 / 60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes);
        if (String(mnum).length == 1) {
            mnum = "0" + mnum;
        }
        seconds = (now - grt) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds);
        if (String(snum).length == 1) {
            snum = "0" + snum;
        }
        document.getElementById("timeDate").innerHTML = "本站已安全运行 " + dnum + " 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
    setInterval("createtime()", 250);
</script>
<!-- 添加网站运行时间》 -->

<style>
  /*返回顶部的css*/
.All_url_totop{
position:fixed;right:10px;width: 35px;height: 35px; border-radius: 5px; position: fixed;right: 10px; cursor: pointer;background-repeat: no-repeat; background-position: 50% 50%; background-color: #000; opacity: .1; transition: opacity .2s ease-in-out;z-index: 99999;
}
#All_url_totop{
background-image:url(data:img/png;base64,R0lGODlhEgAUAJEAAAAAAP///////wAAACH5BAEAAAIALAAAAAASABQAAAImjI+py+IPo4xmWmRpyq5dFkzgoY3VY5KS9ykcKy6vnMEr3W417hQAOw==);
top:384px;
}
#All_url_totop2{
background-image:url(data:img/png;base64,R0lGODlhEgAUAJEAAAAAAP///////wAAACH5BAEAAAIALAAAAAASABQAAAIqlB2peX27nINKNsoswnrTLmABKJKcJH5PGl3siKZdabZgWN2rzuPv/yoAADs=);
top:429px;
}
#All_url_totop:hover,
#All_url_totop2:hover{
opacity: .5;
}
</style>

<script>
 if (!window.location.href.includes("music")) {
        window.onload = function () {
          /*添加返回顶部按钮*/
          var a = document.createElement("a");
          a.setAttribute("href", "JavaScript:window.scrollTo(0,0);");
          a.setAttribute("id", "All_url_totop")
          a.setAttribute("class", "All_url_totop");
          document.body.appendChild(a);
          /*添加返回底部的按钮*/
          var a = document.createElement("a");
          a.setAttribute("href", "JavaScript:window.scrollTo(0,document.body.scrollHeight);");
          a.setAttribute("id", "All_url_totop2")
          a.setAttribute("class", "All_url_totop");
          document.body.appendChild(a);
        }
      }
</script>

        
        <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

      
    </div>
  </div>
  <div class='scripts'>
    <script type="text/javascript">
  const stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')){
        src = stellar.config.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.version = '1.19.0';
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.19.0';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
    root : '/',
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://gcore.jsdelivr.net/npm/jquery@3.6.2/dist/jquery.min.js'
  };

  if ('local_search') {
    stellar.search = {};
    stellar.search.service = 'local_search';
    if (stellar.search.service == 'local_search') {
      let service_obj = Object.assign({}, {"field":"all","path":"/search.json","content":true,"sort":"-date"});
      stellar.search[stellar.search.service] = service_obj;
    }
  }

  // stellar js
  stellar.plugins.stellar = Object.assign({"sites":"/js/plugins/sites.js","friends":"/js/plugins/friends.js","ghinfo":"/js/plugins/ghinfo.js","timeline":"/js/plugins/timeline.js","linkcard":"/js/plugins/linkcard.js","fcircle":"/js/plugins/fcircle.js","weibo":"/js/plugins/weibo.js"});

  stellar.plugins.marked = Object.assign("https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js");
  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/vanilla-lazyload@17.8.3/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@8.4.5/swiper-bundle.min.css","js":"https://unpkg.com/swiper@8.4.5/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://gcore.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://gcore.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://gcore.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.fancybox = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js","css":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css","selector":".swiper-slide img"});
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://unpkg.com/heti@0.9.2/umd/heti.min.css","js":"https://unpkg.com/heti@0.9.2/umd/heti-addon.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.copycode = Object.assign({"enable":true,"js":"/js/plugins/copycode.js","default_text":"Copy","success_text":"Copied"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->

  <script>
  function loadJS() {
    const els = document.querySelectorAll("#comments #giscus");
    if (els.length === 0) return;
    els.forEach((el, i) => {
      try {
        el.innerHTML = '';
      } catch (error) {
        console.log(error);
      }
      var script = document.createElement('script');
      script.src = 'https://giscus.app/client.js';
      script.async = true;
      for (let key of Object.keys(el.attributes)) {
        let attr = el.attributes[key];
        if (['class', 'id'].includes(attr.name) === false) {
          script.setAttribute(attr.name, attr.value);
        }
      }
      el.appendChild(script);
    });
  }
  window.addEventListener('DOMContentLoaded', (event) => {
    loadJS();
  });
</script>




<!-- inject -->


  </div>
</body>
</html>
