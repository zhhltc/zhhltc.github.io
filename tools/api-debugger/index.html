<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>APIè°ƒè¯•å·¥å…· - HTTP/SSE/WebSocket</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 32px;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
            font-size: 14px;
        }

        .tabs {
            display: flex;
            background: #f7f9fc;
            border-bottom: 2px solid #e1e8ed;
        }

        .tab {
            flex: 1;
            padding: 18px;
            text-align: center;
            cursor: pointer;
            font-weight: 600;
            color: #657786;
            transition: all 0.3s ease;
            border-bottom: 3px solid transparent;
        }

        .tab:hover {
            background: #eef2f7;
            color: #667eea;
        }

        .tab.active {
            color: #667eea;
            background: white;
            border-bottom: 3px solid #667eea;
        }

        .tab-content {
            display: none;
            padding: 30px;
        }

        .tab-content.active {
            display: block;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #14171a;
            font-size: 14px;
        }

        .url-input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .method-select {
            padding: 12px 16px;
            border: 2px solid #e1e8ed;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            color: #14171a;
            background: white;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 120px;
        }

        .method-select:focus {
            outline: none;
            border-color: #667eea;
        }

        input[type="text"],
        input[type="url"],
        textarea {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #e1e8ed;
            border-radius: 8px;
            font-size: 14px;
            font-family: inherit;
            transition: all 0.3s ease;
        }

        input[type="text"]:focus,
        input[type="url"]:focus,
        textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        textarea {
            min-height: 120px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            resize: vertical;
        }

        .button {
            padding: 12px 28px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .button-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .button-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        .button-secondary {
            background: #f44336;
            color: white;
            box-shadow: 0 4px 15px rgba(244, 67, 54, 0.4);
        }

        .button-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(244, 67, 54, 0.6);
        }

        .button-add {
            background: #4caf50;
            color: white;
            padding: 8px 16px;
            font-size: 12px;
        }

        .button-add:hover {
            background: #45a049;
        }

        .button-clear {
            background: #ff9800;
            color: white;
            padding: 8px 16px;
            font-size: 12px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
        }

        .button-clear:hover {
            background: #f57c00;
            transform: translateY(-2px);
        }

        .headers-container {
            margin-bottom: 20px;
        }

        .header-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            align-items: center;
        }

        .header-row input {
            flex: 1;
        }

        .button-remove {
            background: #ff5252;
            color: white;
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        .button-remove:hover {
            background: #ff1744;
        }

        .response-container {
            margin-top: 30px;
            padding: 20px;
            background: #f7f9fc;
            border-radius: 8px;
            border: 2px solid #e1e8ed;
        }

        .response-container h3 {
            margin-bottom: 15px;
            color: #14171a;
            font-size: 18px;
        }

        .response-content {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 13px;
            overflow-x: auto;
            max-height: 500px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .response-meta {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
            padding: 10px;
            background: white;
            border-radius: 6px;
        }

        .response-meta-item {
            font-size: 13px;
        }

        .response-meta-label {
            font-weight: 600;
            color: #657786;
            margin-right: 5px;
        }

        .response-meta-value {
            color: #14171a;
            font-weight: 700;
        }

        .status-success {
            color: #4caf50;
        }

        .status-error {
            color: #f44336;
        }

        .event-log {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 13px;
            max-height: 400px;
            overflow-y: auto;
            margin-top: 20px;
        }

        .event-item {
            padding: 8px 0;
            border-bottom: 1px solid #333;
        }

        .event-item:last-child {
            border-bottom: none;
        }

        .event-time {
            color: #858585;
            font-size: 11px;
            margin-right: 10px;
        }

        .event-type {
            color: #4fc3f7;
            font-weight: 600;
            margin-right: 10px;
        }

        .event-data {
            color: #a5d6a7;
        }

        .ws-status {
            display: inline-block;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            margin-left: 10px;
        }

        .ws-status.connected {
            background: #e8f5e9;
            color: #2e7d32;
        }

        .ws-status.disconnected {
            background: #ffebee;
            color: #c62828;
        }

        .message-input-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .message-input-group input {
            flex: 1;
        }

        .collapsible-section {
            margin-bottom: 20px;
        }

        .section-header {
            cursor: pointer;
            padding: 12px;
            background: #f7f9fc;
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
            transition: all 0.3s ease;
        }

        .section-header:hover {
            background: #eef2f7;
        }

        .section-header h4 {
            color: #14171a;
            font-size: 15px;
        }

        .section-toggle {
            color: #657786;
            font-size: 18px;
        }

        .section-content {
            padding: 15px 0;
        }

        .section-content.collapsed {
            display: none;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .response-container {
            animation: fadeIn 0.5s ease;
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #657786;
        }

        .empty-state svg {
            width: 80px;
            height: 80px;
            margin-bottom: 20px;
            opacity: 0.5;
        }

        #curlImportSection,
        #sseCurlImportSection,
        #wsCurlImportSection {
            background: #f7f9fc;
            padding: 20px;
            border-radius: 8px;
            border: 2px dashed #667eea;
            animation: fadeIn 0.3s ease;
        }

        #curlImportSection textarea,
        #sseCurlImportSection textarea,
        #wsCurlImportSection textarea {
            min-height: 150px;
            background: white;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 13px;
        }

        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.05);
            }
        }

        /* Loading çŠ¶æ€æ ·å¼ */
        .button-loading {
            position: relative;
            pointer-events: none;
            opacity: 0.7;
        }

        .button-loading::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            top: 50%;
            left: 50%;
            margin-left: -8px;
            margin-top: -8px;
            border: 2px solid #ffffff;
            border-radius: 50%;
            border-top-color: transparent;
            animation: spin 0.6s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸš€ APIè°ƒè¯•å·¥å…·</h1>
            <p>æ”¯æŒ HTTP API / Server-Sent Events / WebSocket è°ƒè¯•</p>
        </div>

        <div class="tabs">
            <div class="tab active" onclick="switchTab('http')">HTTP è¯·æ±‚</div>
            <div class="tab" onclick="switchTab('sse')">SSE è°ƒè¯•</div>
            <div class="tab" onclick="switchTab('websocket')">WebSocket è°ƒè¯•</div>
        </div>

        <!-- HTTP Tab -->
        <div id="http" class="tab-content active">
            <div class="url-input-group">
                <select id="httpMethod" class="method-select">
                    <option value="GET">GET</option>
                    <option value="POST">POST</option>
                    <option value="PUT">PUT</option>
                    <option value="DELETE">DELETE</option>
                    <option value="PATCH">PATCH</option>
                    <option value="HEAD">HEAD</option>
                    <option value="OPTIONS">OPTIONS</option>
                </select>
                <input type="url" id="httpUrl" placeholder="è¾“å…¥è¯·æ±‚URLï¼Œä¾‹å¦‚ï¼šhttps://api.example.com/endpoint" value="https://jsonplaceholder.typicode.com/posts/1">
                <button id="httpSendBtn" class="button button-primary" onclick="sendHttpRequest()">å‘é€è¯·æ±‚</button>
                <button class="button button-add" onclick="previewRequest()">ğŸ” é¢„è§ˆè¯·æ±‚</button>
            </div>

            <div class="button-group" style="margin-bottom: 20px;">
                <button class="button button-add" onclick="copyCurl()">ğŸ“‹ å¤åˆ¶ä¸º cURL</button>
                <button class="button button-add" onclick="toggleCurlImport()">ğŸ“¥ å¯¼å…¥ cURL</button>
                <button class="button button-clear" onclick="clearHttpForm()">ğŸ—‘ï¸ ä¸€é”®æ¸…ç©º</button>
            </div>

            <div id="requestPreview" style="display: none; margin-bottom: 20px;">
                <div style="background: #fff3cd; border: 2px solid #ffc107; padding: 20px; border-radius: 8px;">
                    <h4 style="margin-bottom: 15px; color: #856404; display: flex; align-items: center; justify-content: space-between;">
                        <span>ğŸ” å³å°†å‘é€çš„è¯·æ±‚è¯¦æƒ…</span>
                        <button class="button-remove" onclick="document.getElementById('requestPreview').style.display='none'">å…³é—­</button>
                    </h4>
                    <div style="background: #1e1e1e; color: #d4d4d4; padding: 15px; border-radius: 8px; font-family: Monaco, monospace; font-size: 13px; max-height: 400px; overflow-y: auto;">
                        <pre id="requestPreviewContent" style="margin: 0; white-space: pre-wrap; word-wrap: break-word;"></pre>
                    </div>
                </div>
            </div>

            <div id="curlImportSection" style="display: none; margin-bottom: 20px;">
                <div class="form-group">
                    <label>ç²˜è´´ cURL å‘½ä»¤</label>
                    <textarea id="curlInput" placeholder="ç²˜è´´cURLå‘½ä»¤ï¼Œä¾‹å¦‚ï¼š&#10;curl -X POST 'https://api.example.com/endpoint' \&#10;  -H 'Content-Type: application/json' \&#10;  -d '{&quot;key&quot;:&quot;value&quot;}'"></textarea>
                </div>
                <div class="button-group">
                    <button class="button button-primary" onclick="importCurl()">å¯¼å…¥å¹¶å¡«å……</button>
                    <button class="button button-add" onclick="previewCurl()">ğŸ” é¢„è§ˆè§£æç»“æœ</button>
                    <button class="button button-secondary" onclick="toggleCurlImport()">å–æ¶ˆ</button>
                </div>
                
                <div id="curlPreview" style="display: none; margin-top: 15px;">
                    <div style="background: #1e1e1e; color: #d4d4d4; padding: 15px; border-radius: 8px; font-family: Monaco, monospace; font-size: 13px; max-height: 300px; overflow-y: auto;">
                        <pre id="curlPreviewContent" style="margin: 0; white-space: pre-wrap; word-wrap: break-word;"></pre>
                    </div>
                </div>
            </div>

            <div class="collapsible-section">
                <div class="section-header" onclick="toggleSection(this)">
                    <h4>ğŸ“‹ è¯·æ±‚å¤´ (Headers)</h4>
                    <span class="section-toggle">â–¼</span>
                </div>
                <div class="section-content">
                    <div id="httpHeaders" class="headers-container">
                        <div class="header-row">
                            <input type="text" placeholder="Header Name" value="Content-Type">
                            <input type="text" placeholder="Header Value" value="application/json">
                            <button class="button-remove" onclick="removeHeader(this)">åˆ é™¤</button>
                        </div>
                    </div>
                    <button class="button button-add" onclick="addHttpHeader()">+ æ·»åŠ è¯·æ±‚å¤´</button>
                </div>
            </div>

            <div class="collapsible-section">
                <div class="section-header" onclick="toggleSection(this)">
                    <h4>ğŸ“ è¯·æ±‚ä½“ (Body)</h4>
                    <span class="section-toggle">â–¼</span>
                </div>
                <div class="section-content">
                    <div class="form-group">
                        <select id="bodyType" class="method-select" onchange="updateBodyPlaceholder()">
                            <option value="json">JSON</option>
                            <option value="text">Plain Text</option>
                            <option value="form">Form Data</option>
                        </select>
                    </div>
                    <textarea id="httpBody" placeholder='{"key": "value"}'></textarea>
                </div>
            </div>

            <div id="httpResponse" class="response-container" style="display: none;">
                <h3>ğŸ“¥ å“åº”ç»“æœ</h3>
                <div class="response-meta">
                    <div class="response-meta-item">
                        <span class="response-meta-label">çŠ¶æ€ç :</span>
                        <span class="response-meta-value" id="httpStatus"></span>
                    </div>
                    <div class="response-meta-item">
                        <span class="response-meta-label">å“åº”æ—¶é—´:</span>
                        <span class="response-meta-value" id="httpTime"></span>
                    </div>
                    <div class="response-meta-item">
                        <span class="response-meta-label">å¤§å°:</span>
                        <span class="response-meta-value" id="httpSize"></span>
                    </div>
                </div>
                <div class="response-content" id="httpResponseContent"></div>
                <button class="button button-add" onclick="copyResponseDetails()" style="margin-top: 15px;">ğŸ“‹ å¤åˆ¶å®Œæ•´æ—¥å¿—</button>
            </div>
        </div>

        <!-- SSE Tab -->
        <div id="sse" class="tab-content">
            <div class="url-input-group">
                <input type="url" id="sseUrl" placeholder="è¾“å…¥SSE URLï¼Œä¾‹å¦‚ï¼šhttps://example.com/events" style="flex: 1;">
                <button id="sseConnectBtn" class="button button-primary" onclick="connectSSE()">è¿æ¥</button>
                <button id="sseDisconnectBtn" class="button button-secondary" onclick="disconnectSSE()" disabled>æ–­å¼€</button>
            </div>

            <div class="button-group" style="margin-bottom: 20px; margin-top: 10px;">
                <button class="button button-add" onclick="copySSECurl()">ğŸ“‹ å¤åˆ¶ä¸º cURL</button>
                <button class="button button-add" onclick="toggleSSECurlImport()">ğŸ“¥ å¯¼å…¥ cURL</button>
                <button class="button button-clear" onclick="clearSSEForm()">ğŸ—‘ï¸ ä¸€é”®æ¸…ç©º</button>
            </div>

            <div id="sseCurlImportSection" style="display: none; margin-bottom: 20px;">
                <div class="form-group">
                    <label>ç²˜è´´ cURL å‘½ä»¤</label>
                    <textarea id="sseCurlInput" placeholder="ç²˜è´´SSEç›¸å…³çš„cURLå‘½ä»¤ï¼Œä¾‹å¦‚ï¼š&#10;curl 'https://example.com/events' \&#10;  -H 'Authorization: Bearer token' \&#10;  -H 'Accept: text/event-stream'"></textarea>
                </div>
                <div class="button-group">
                    <button class="button button-primary" onclick="importSSECurl()">å¯¼å…¥å¹¶å¡«å……</button>
                    <button class="button button-add" onclick="previewSSECurl()">ğŸ” é¢„è§ˆè§£æç»“æœ</button>
                    <button class="button button-secondary" onclick="toggleSSECurlImport()">å–æ¶ˆ</button>
                </div>
                
                <div id="sseCurlPreview" style="display: none; margin-top: 15px;">
                    <div style="background: #1e1e1e; color: #d4d4d4; padding: 15px; border-radius: 8px; font-family: Monaco, monospace; font-size: 13px; max-height: 300px; overflow-y: auto;">
                        <pre id="sseCurlPreviewContent" style="margin: 0; white-space: pre-wrap; word-wrap: break-word;"></pre>
                    </div>
                </div>
            </div>

            <div class="collapsible-section">
                <div class="section-header" onclick="toggleSection(this)">
                    <h4>ğŸ“‹ è¯·æ±‚å¤´ (Headers)</h4>
                    <span class="section-toggle">â–¼</span>
                </div>
                <div class="section-content">
                    <div id="sseHeaders" class="headers-container">
                        <div class="header-row">
                            <input type="text" placeholder="Header Name" value="Authorization">
                            <input type="text" placeholder="Header Value" value="Bearer token">
                            <button class="button-remove" onclick="removeHeader(this)">åˆ é™¤</button>
                        </div>
                    </div>
                    <button class="button button-add" onclick="addSseHeader()">+ æ·»åŠ è¯·æ±‚å¤´</button>
                    <p style="margin-top: 10px; color: #657786; font-size: 13px;">
                        âš ï¸ æ³¨æ„ï¼šæµè§ˆå™¨çš„EventSource APIä¸æ”¯æŒè‡ªå®šä¹‰è¯·æ±‚å¤´ã€‚å¦‚éœ€è‡ªå®šä¹‰è¯·æ±‚å¤´ï¼Œè¯·ä½¿ç”¨fetch with streamingæˆ–æœåŠ¡ç«¯ä»£ç†ã€‚
                    </p>
                </div>
            </div>

            <div class="response-container">
                <h3>ğŸ“¡ äº‹ä»¶æ—¥å¿—
                    <span class="ws-status disconnected" id="sseStatus">æœªè¿æ¥</span>
                </h3>
                <div style="margin-bottom: 10px;">
                    <label style="font-size: 13px; color: #657786;">
                        <input type="checkbox" id="sseDebugMode" onchange="toggleSSEDebugMode()">
                        æ˜¾ç¤ºåŸå§‹æ•°æ®æµï¼ˆè°ƒè¯•æ¨¡å¼ï¼‰
                    </label>
                </div>
                <div class="event-log" id="sseLog">
                    <div class="empty-state">
                        <div style="font-size: 40px; margin-bottom: 10px;">ğŸ“¡</div>
                        <p>ç‚¹å‡»"è¿æ¥"æŒ‰é’®å¼€å§‹æ¥æ”¶æœåŠ¡å™¨æ¨é€äº‹ä»¶</p>
                    </div>
                </div>
                <button class="button button-add" onclick="clearSSELog()" style="margin-top: 15px;">æ¸…ç©ºæ—¥å¿—</button>
            </div>
        </div>

        <!-- WebSocket Tab -->
        <div id="websocket" class="tab-content">
            <div class="url-input-group">
                <input type="text" id="wsUrl" placeholder="è¾“å…¥WebSocket URLï¼Œä¾‹å¦‚ï¼šws://localhost:8080 æˆ– wss://example.com/ws" value="wss://echo.websocket.org/">
                <button id="wsConnectBtn" class="button button-primary" onclick="connectWebSocket()">è¿æ¥</button>
                <button id="wsDisconnectBtn" class="button button-secondary" onclick="disconnectWebSocket()" disabled>æ–­å¼€</button>
            </div>

            <div class="button-group" style="margin-bottom: 20px; margin-top: 10px;">
                <button class="button button-add" onclick="copyWSInfo()">ğŸ“‹ å¤åˆ¶è¿æ¥ä¿¡æ¯</button>
                <button class="button button-add" onclick="toggleWSCurlImport()">ğŸ“¥ ä» URL å¯¼å…¥</button>
                <button class="button button-clear" onclick="clearWSForm()">ğŸ—‘ï¸ ä¸€é”®æ¸…ç©º</button>
            </div>

            <div id="wsCurlImportSection" style="display: none; margin-bottom: 20px;">
                <div class="form-group">
                    <label>ç²˜è´´ WebSocket URL æˆ– cURL å‘½ä»¤</label>
                    <textarea id="wsCurlInput" placeholder="æ”¯æŒå¤šç§æ ¼å¼ï¼š&#10;1. ç›´æ¥WebSocket URL: wss://example.com/ws?token=xxx&#10;2. HTTP URL (è‡ªåŠ¨è½¬æ¢): https://example.com/ws&#10;3. cURLå‘½ä»¤: curl 'https://example.com/ws' -H 'Authorization: Bearer token'&#10;&#10;æ³¨æ„ï¼šWebSocketè¿æ¥æœ¬èº«ä¸æ”¯æŒè‡ªå®šä¹‰è¯·æ±‚å¤´ï¼Œè¯·æ±‚å¤´é€šå¸¸éœ€è¦é€šè¿‡URLå‚æ•°ä¼ é€’ã€‚"></textarea>
                </div>
                <div class="button-group">
                    <button class="button button-primary" onclick="importWSCurl()">å¯¼å…¥å¹¶å¡«å……</button>
                    <button class="button button-add" onclick="previewWSCurl()">ğŸ” é¢„è§ˆè§£æç»“æœ</button>
                    <button class="button button-secondary" onclick="toggleWSCurlImport()">å–æ¶ˆ</button>
                </div>
                
                <div id="wsCurlPreview" style="display: none; margin-top: 15px;">
                    <div style="background: #1e1e1e; color: #d4d4d4; padding: 15px; border-radius: 8px; font-family: Monaco, monospace; font-size: 13px; max-height: 300px; overflow-y: auto;">
                        <pre id="wsCurlPreviewContent" style="margin: 0; white-space: pre-wrap; word-wrap: break-word;"></pre>
                    </div>
                </div>
            </div>

            <div class="collapsible-section">
                <div class="section-header" onclick="toggleSection(this)">
                    <h4>ğŸ“‹ è‡ªå®šä¹‰è¯·æ±‚å¤´ (Headers)</h4>
                    <span class="section-toggle">â–¼</span>
                </div>
                <div class="section-content collapsed">
                    <div id="wsHeaders" class="headers-container">
                        <div class="header-row">
                            <input type="text" placeholder="Header Name" value="Authorization">
                            <input type="text" placeholder="Header Value" value="Bearer token">
                            <button class="button-remove" onclick="removeHeader(this)">åˆ é™¤</button>
                        </div>
                    </div>
                    <button class="button button-add" onclick="addWSHeader()">+ æ·»åŠ è¯·æ±‚å¤´</button>
                    <p style="margin-top: 10px; color: #657786; font-size: 13px;">
                        âš ï¸ æ³¨æ„ï¼šæµè§ˆå™¨WebSocketä¸æ”¯æŒè‡ªå®šä¹‰æ¡æ‰‹å¤´ã€‚è¿™äº›å¤´å°†åœ¨è¿æ¥æˆåŠŸåé€šè¿‡é¦–æ¡æ¶ˆæ¯å‘é€ã€‚
                    </p>
                </div>
            </div>

            <div class="collapsible-section">
                <div class="section-header" onclick="toggleSection(this)">
                    <h4>ğŸ”Œ è¿æ¥åè®® (Protocols)</h4>
                    <span class="section-toggle">â–¼</span>
                </div>
                <div class="section-content collapsed">
                    <input type="text" id="wsProtocols" placeholder="å­åè®®ï¼Œå¤šä¸ªç”¨é€—å·åˆ†éš”ï¼Œä¾‹å¦‚ï¼šchat, superchat">
                </div>
            </div>

            <div class="collapsible-section">
                <div class="section-header" onclick="toggleSection(this)">
                    <h4>ğŸ’“ å¿ƒè·³æ£€æµ‹ (Heartbeat)</h4>
                    <span class="section-toggle">â–¼</span>
                </div>
                <div class="section-content collapsed">
                    <div style="margin-bottom: 15px;">
                        <label style="font-size: 14px; color: #14171a; display: flex; align-items: center; cursor: pointer;">
                            <input type="checkbox" id="wsHeartbeatEnabled" style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                            å¯ç”¨å¿ƒè·³æ£€æµ‹
                        </label>
                    </div>
                    
                    <div class="form-group">
                        <label>å¿ƒè·³é—´éš” (ç§’)</label>
                        <input type="number" id="wsHeartbeatInterval" value="30" min="5" max="300" placeholder="å¿ƒè·³é—´éš”ï¼ˆç§’ï¼‰">
                    </div>
                    
                    <div class="form-group">
                        <label>å¿ƒè·³æ¶ˆæ¯å†…å®¹</label>
                        <input type="text" id="wsHeartbeatMessage" value="ping" placeholder="å¿ƒè·³æ¶ˆæ¯ï¼Œä¾‹å¦‚ï¼šping æˆ– {&quot;type&quot;:&quot;ping&quot;}">
                    </div>
                    
                    <div class="form-group">
                        <label>è¶…æ—¶æ—¶é—´ (ç§’)</label>
                        <input type="number" id="wsHeartbeatTimeout" value="10" min="3" max="60" placeholder="è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰">
                    </div>
                    
                    <div style="margin-top: 10px;">
                        <label style="font-size: 14px; color: #14171a; display: flex; align-items: center; cursor: pointer;">
                            <input type="checkbox" id="wsAutoReconnect" style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                            è¶…æ—¶åè‡ªåŠ¨é‡è¿
                        </label>
                    </div>
                    
                    <p style="margin-top: 10px; color: #657786; font-size: 13px;">
                        ğŸ’¡ å¿ƒè·³æœºåˆ¶ï¼šå®šæ—¶å‘é€å¿ƒè·³æ¶ˆæ¯ï¼Œè‹¥è¶…è¿‡æŒ‡å®šæ—¶é—´æœªæ”¶åˆ°ä»»ä½•æ¶ˆæ¯ï¼Œåˆ™åˆ¤å®šè¿æ¥å¼‚å¸¸ã€‚
                    </p>
                </div>
            </div>

            <div class="response-container">
                <h3>ğŸ’¬ æ¶ˆæ¯è®°å½•
                    <span class="ws-status disconnected" id="wsStatus">æœªè¿æ¥</span>
                </h3>
                <div style="margin-bottom: 10px;">
                    <label style="font-size: 13px; color: #657786;">
                        <input type="checkbox" id="wsDebugMode" onchange="toggleWSDebugMode()">
                        æ˜¾ç¤ºè¯¦ç»†è°ƒè¯•ä¿¡æ¯
                    </label>
                </div>
                <div class="event-log" id="wsLog">
                    <div class="empty-state">
                        <div style="font-size: 40px; margin-bottom: 10px;">ğŸ’¬</div>
                        <p>ç‚¹å‡»"è¿æ¥"æŒ‰é’®å¼€å§‹WebSocketé€šä¿¡</p>
                    </div>
                </div>
                <button class="button button-add" onclick="clearWSLog()" style="margin-top: 15px;">æ¸…ç©ºæ—¥å¿—</button>
            </div>

            <div class="form-group">
                <label>ğŸ“¤ å‘é€æ¶ˆæ¯</label>
                <div class="message-input-group">
                    <input type="text" id="wsMessage" placeholder="è¾“å…¥è¦å‘é€çš„æ¶ˆæ¯" onkeypress="if(event.key === 'Enter') sendWebSocketMessage()">
                    <button class="button button-primary" onclick="sendWebSocketMessage()">å‘é€</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentTab = 'http';
        let sseConnection = null;
        let wsConnection = null;
        let sseDebugMode = false;
        let wsDebugMode = false;
        let wsHeartbeatTimer = null;
        let wsHeartbeatTimeoutTimer = null;
        let wsLastMessageTime = null;

        // Tabåˆ‡æ¢
        function switchTab(tabName) {
            const tabs = document.querySelectorAll('.tab');
            const contents = document.querySelectorAll('.tab-content');
            
            tabs.forEach(tab => tab.classList.remove('active'));
            contents.forEach(content => content.classList.remove('active'));
            
            document.querySelector(`.tab:nth-child(${tabName === 'http' ? 1 : tabName === 'sse' ? 2 : 3})`).classList.add('active');
            document.getElementById(tabName).classList.add('active');
            
            currentTab = tabName;
        }

        // æŠ˜å /å±•å¼€
        function toggleSection(header) {
            const content = header.nextElementSibling;
            const toggle = header.querySelector('.section-toggle');
            content.classList.toggle('collapsed');
            toggle.textContent = content.classList.contains('collapsed') ? 'â–¶' : 'â–¼';
        }

        // HTTPè¯·æ±‚å¤´ç®¡ç†
        function addHttpHeader() {
            const container = document.getElementById('httpHeaders');
            const row = document.createElement('div');
            row.className = 'header-row';
            row.innerHTML = `
                <input type="text" placeholder="Header Name">
                <input type="text" placeholder="Header Value">
                <button class="button-remove" onclick="removeHeader(this)">åˆ é™¤</button>
            `;
            container.appendChild(row);
        }

        function addSseHeader() {
            const container = document.getElementById('sseHeaders');
            const row = document.createElement('div');
            row.className = 'header-row';
            row.innerHTML = `
                <input type="text" placeholder="Header Name">
                <input type="text" placeholder="Header Value">
                <button class="button-remove" onclick="removeHeader(this)">åˆ é™¤</button>
            `;
            container.appendChild(row);
        }

        function addWSHeader() {
            const container = document.getElementById('wsHeaders');
            const row = document.createElement('div');
            row.className = 'header-row';
            row.innerHTML = `
                <input type="text" placeholder="Header Name">
                <input type="text" placeholder="Header Value">
                <button class="button-remove" onclick="removeHeader(this)">åˆ é™¤</button>
            `;
            container.appendChild(row);
        }

        function removeHeader(button) {
            button.parentElement.remove();
        }

        function updateBodyPlaceholder() {
            const bodyType = document.getElementById('bodyType').value;
            const textarea = document.getElementById('httpBody');
            
            switch(bodyType) {
                case 'json':
                    textarea.placeholder = '{"key": "value"}';
                    break;
                case 'text':
                    textarea.placeholder = 'Plain text content...';
                    break;
                case 'form':
                    textarea.placeholder = 'key1=value1&key2=value2';
                    break;
            }
        }

        // é¢„è§ˆè¯·æ±‚è¯¦æƒ…
        function previewRequest() {
            const method = document.getElementById('httpMethod').value;
            const url = document.getElementById('httpUrl').value;
            const body = document.getElementById('httpBody').value;
            const bodyType = document.getElementById('bodyType').value;

            if (!url) {
                alert('è¯·å…ˆè¾“å…¥URL');
                return;
            }

            // æ”¶é›†è¯·æ±‚å¤´
            const headers = {};
            const headerRows = document.querySelectorAll('#httpHeaders .header-row');
            headerRows.forEach(row => {
                const inputs = row.querySelectorAll('input');
                const name = inputs[0].value.trim();
                const value = inputs[1].value.trim();
                if (name) {
                    headers[name] = value;
                }
            });

            // æ„å»ºé¢„è§ˆå†…å®¹
            let preview = 'ğŸ” è¯·æ±‚è¯¦æƒ…é¢„è§ˆ\n';
            preview += '='.repeat(70) + '\n\n';
            
            preview += `ğŸ“® è¯·æ±‚æ–¹æ³•: ${method}\n\n`;
            preview += `ğŸ“ è¯·æ±‚URL:\n${url}\n\n`;
            
            // è§£æ URL å‚æ•°
            try {
                const urlObj = new URL(url);
                if (urlObj.search) {
                    preview += `ğŸ”— URLå‚æ•° (Query Parameters):\n`;
                    urlObj.searchParams.forEach((value, key) => {
                        preview += `  â€¢ ${key} = ${value}\n`;
                    });
                    preview += '\n';
                }
            } catch (e) {
                preview += `âš ï¸ URLæ ¼å¼å¯èƒ½ä¸å®Œæ•´æˆ–ä¸æ­£ç¡®\n\n`;
            }

            preview += `ğŸ“‹ è¯·æ±‚å¤´ (Headers) [å…±${Object.keys(headers).length}ä¸ª]:\n`;
            if (Object.keys(headers).length > 0) {
                for (const [key, value] of Object.entries(headers)) {
                    preview += `  â€¢ ${key}: ${value}\n`;
                }
            } else {
                preview += `  (æ— )\n`;
            }
            preview += '\n';

            if (body && ['POST', 'PUT', 'PATCH'].includes(method)) {
                preview += `ğŸ“ è¯·æ±‚ä½“ (Body):\n`;
                preview += `  ç±»å‹: ${bodyType}\n`;
                preview += `  å¤§å°: ${body.length} å­—ç¬¦ (${new Blob([body]).size} bytes)\n\n`;
                preview += `  å†…å®¹:\n`;
                preview += `${'â”€'.repeat(66)}\n`;
                
                // å¦‚æœæ˜¯JSONï¼Œå°è¯•éªŒè¯æ ¼å¼
                if (bodyType === 'json') {
                    try {
                        const parsed = JSON.parse(body);
                        preview += JSON.stringify(parsed, null, 2);
                        preview += '\nâœ… JSON æ ¼å¼æœ‰æ•ˆ\n';
                    } catch (e) {
                        preview += body;
                        preview += `\n\nâŒ JSON æ ¼å¼é”™è¯¯: ${e.message}\n`;
                    }
                } else {
                    preview += body;
                }
                preview += `\n${'â”€'.repeat(66)}\n\n`;
            } else {
                preview += `ğŸ“ è¯·æ±‚ä½“: (æ— )\n\n`;
            }

            // ç”Ÿæˆç­‰æ•ˆçš„ cURL å‘½ä»¤
            preview += `ğŸ’¡ ç­‰æ•ˆ cURL å‘½ä»¤:\n`;
            preview += `${'â”€'.repeat(66)}\n`;
            let curlCmd = `curl -X ${method} '${url}'`;
            for (const [key, value] of Object.entries(headers)) {
                curlCmd += ` \\\n  -H '${key}: ${value}'`;
            }
            if (body && ['POST', 'PUT', 'PATCH'].includes(method)) {
                const escapedBody = body.replace(/'/g, "'\\''");
                curlCmd += ` \\\n  -d '${escapedBody}'`;
            }
            preview += curlCmd;
            preview += `\n${'â”€'.repeat(66)}\n`;

            preview += '\n' + '='.repeat(70);

            document.getElementById('requestPreviewContent').textContent = preview;
            document.getElementById('requestPreview').style.display = 'block';
            
            // æ»šåŠ¨åˆ°é¢„è§ˆåŒºåŸŸ
            document.getElementById('requestPreview').scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        // HTTPè¯·æ±‚
        async function sendHttpRequest() {
            const method = document.getElementById('httpMethod').value;
            const url = document.getElementById('httpUrl').value;
            const body = document.getElementById('httpBody').value;
            const bodyType = document.getElementById('bodyType').value;

            if (!url) {
                alert('è¯·è¾“å…¥URL');
                return;
            }

            // æ”¶é›†è¯·æ±‚å¤´
            const headers = {};
            const headerRows = document.querySelectorAll('#httpHeaders .header-row');
            headerRows.forEach(row => {
                const inputs = row.querySelectorAll('input');
                const name = inputs[0].value.trim();
                const value = inputs[1].value.trim();
                if (name) {
                    headers[name] = value;
                }
            });

            // è®¾ç½®æŒ‰é’®ä¸ºloadingçŠ¶æ€
            const sendBtn = document.getElementById('httpSendBtn');
            const originalText = sendBtn.textContent;
            sendBtn.classList.add('button-loading');
            sendBtn.textContent = 'è¯·æ±‚ä¸­...';
            sendBtn.disabled = true;

            const startTime = Date.now();

            try {
                const options = {
                    method: method,
                    headers: headers
                };

                if (body && ['POST', 'PUT', 'PATCH'].includes(method)) {
                    options.body = body;
                    
                    if (bodyType === 'json' && !headers['Content-Type']) {
                        options.headers['Content-Type'] = 'application/json';
                    } else if (bodyType === 'form' && !headers['Content-Type']) {
                        options.headers['Content-Type'] = 'application/x-www-form-urlencoded';
                    }
                }

                const response = await fetch(url, options);
                const endTime = Date.now();
                const duration = endTime - startTime;

                const contentType = response.headers.get('content-type');
                let responseText;
                
                if (contentType && contentType.includes('application/json')) {
                    const json = await response.json();
                    responseText = JSON.stringify(json, null, 2);
                } else {
                    responseText = await response.text();
                }

                // æ˜¾ç¤ºå“åº”
                document.getElementById('httpResponse').style.display = 'block';
                document.getElementById('httpStatus').textContent = response.status;
                document.getElementById('httpStatus').className = 'response-meta-value ' + (response.ok ? 'status-success' : 'status-error');
                document.getElementById('httpTime').textContent = duration + ' ms';
                document.getElementById('httpSize').textContent = new Blob([responseText]).size + ' bytes';
                
                // æ ¼å¼åŒ–è¯·æ±‚ä¿¡æ¯
                let requestInfo = '// ========== è¯·æ±‚ä¿¡æ¯ ==========\n';
                requestInfo += `// æ–¹æ³•: ${method}\n`;
                requestInfo += `// URL: ${url}\n`;
                requestInfo += '// è¯·æ±‚å¤´:\n';
                for (const [key, value] of Object.entries(headers)) {
                    requestInfo += `//   ${key}: ${value}\n`;
                }
                if (body && ['POST', 'PUT', 'PATCH'].includes(method)) {
                    requestInfo += `// è¯·æ±‚ä½“ (${body.length} å­—ç¬¦):\n`;
                    requestInfo += `//   ${body.substring(0, 100)}${body.length > 100 ? '...' : ''}\n`;
                }
                requestInfo += '\n';

                // æ ¼å¼åŒ–å“åº”å¤´
                let headersText = '// ========== å“åº”ä¿¡æ¯ ==========\n';
                headersText += '// Response Headers:\n';
                response.headers.forEach((value, key) => {
                    headersText += `// ${key}: ${value}\n`;
                });
                headersText += '// Response Body:\n';
                
                document.getElementById('httpResponseContent').textContent = requestInfo + headersText + responseText;

            } catch (error) {
                // æ ¼å¼åŒ–è¯·æ±‚ä¿¡æ¯ï¼ˆå³ä½¿å¤±è´¥ä¹Ÿè¦æ˜¾ç¤ºï¼‰
                let requestInfo = '// ========== è¯·æ±‚ä¿¡æ¯ ==========\n';
                requestInfo += `// æ–¹æ³•: ${method}\n`;
                requestInfo += `// URL: ${url}\n`;
                requestInfo += '// è¯·æ±‚å¤´:\n';
                for (const [key, value] of Object.entries(headers)) {
                    requestInfo += `//   ${key}: ${value}\n`;
                }
                if (body && ['POST', 'PUT', 'PATCH'].includes(method)) {
                    requestInfo += `// è¯·æ±‚ä½“:\n${body}\n`;
                }
                requestInfo += '\n// ========== é”™è¯¯ä¿¡æ¯ ==========\n';
                
                document.getElementById('httpResponse').style.display = 'block';
                document.getElementById('httpStatus').textContent = 'ERROR';
                document.getElementById('httpStatus').className = 'response-meta-value status-error';
                document.getElementById('httpTime').textContent = '-';
                document.getElementById('httpSize').textContent = '-';
                document.getElementById('httpResponseContent').textContent = requestInfo + 'âŒ é”™è¯¯: ' + error.message + '\n\nå¯èƒ½çš„åŸå› ï¼š\n1. ç½‘ç»œè¿æ¥é—®é¢˜\n2. URL ä¸æ­£ç¡®\n3. CORS è·¨åŸŸé™åˆ¶\n4. æœåŠ¡å™¨æœªå“åº”';
            } finally {
                // æ¢å¤æŒ‰é’®çŠ¶æ€
                sendBtn.classList.remove('button-loading');
                sendBtn.textContent = originalText;
                sendBtn.disabled = false;
            }
        }

        // SSE è°ƒè¯•æ¨¡å¼åˆ‡æ¢
        function toggleSSEDebugMode() {
            sseDebugMode = document.getElementById('sseDebugMode').checked;
            if (sseDebugMode) {
                logSSEEvent('info', 'ğŸ” è°ƒè¯•æ¨¡å¼å·²å¯ç”¨ - å°†æ˜¾ç¤ºåŸå§‹æ•°æ®æµ');
            } else {
                logSSEEvent('info', 'ğŸ” è°ƒè¯•æ¨¡å¼å·²å…³é—­');
            }
        }

        // SSE å¯¼å‡ºä¸º cURL
        function copySSECurl() {
            const url = document.getElementById('sseUrl').value;

            if (!url) {
                alert('è¯·å…ˆè¾“å…¥SSE URL');
                return;
            }

            // æ”¶é›†è¯·æ±‚å¤´
            const headers = {};
            const headerRows = document.querySelectorAll('#sseHeaders .header-row');
            headerRows.forEach(row => {
                const inputs = row.querySelectorAll('input');
                const name = inputs[0].value.trim();
                const value = inputs[1].value.trim();
                if (name) {
                    headers[name] = value;
                }
            });

            // æ„å»ºcurlå‘½ä»¤
            let curlCommand = `curl '${url}'`;

            // æ·»åŠ Acceptå¤´ï¼ˆSSEæ ‡å‡†ï¼‰
            if (!headers['Accept']) {
                curlCommand += ` \\\n  -H 'Accept: text/event-stream'`;
            }

            // æ·»åŠ å…¶ä»–è¯·æ±‚å¤´
            for (const [key, value] of Object.entries(headers)) {
                curlCommand += ` \\\n  -H '${key}: ${value}'`;
            }

            // æ·»åŠ  --no-buffer å‚æ•°ä»¥å®æ—¶è¾“å‡º
            curlCommand += ` \\\n  --no-buffer`;

            // å¤åˆ¶åˆ°å‰ªè´´æ¿
            navigator.clipboard.writeText(curlCommand).then(() => {
                const btn = event.target;
                const originalText = btn.textContent;
                btn.textContent = 'âœ… å·²å¤åˆ¶';
                btn.style.background = '#4caf50';
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.background = '';
                }, 2000);
            }).catch(err => {
                alert('å¤åˆ¶å¤±è´¥ï¼š' + err.message + '\n\nå‘½ä»¤å·²ç”Ÿæˆï¼š\n' + curlCommand);
            });
        }

        // SSE cURL å¯¼å…¥åŠŸèƒ½
        function toggleSSECurlImport() {
            const section = document.getElementById('sseCurlImportSection');
            section.style.display = section.style.display === 'none' ? 'block' : 'none';
            if (section.style.display === 'block') {
                document.getElementById('sseCurlInput').focus();
            }
        }

        function previewSSECurl() {
            const curlInput = document.getElementById('sseCurlInput').value.trim();

            if (!curlInput) {
                alert('è¯·å…ˆç²˜è´´cURLå‘½ä»¤æˆ–URL');
                return;
            }

            try {
                const parsed = parseCurlCommand(curlInput);
                
                let preview = 'ğŸ” SSE cURL è§£æé¢„è§ˆ\n';
                preview += '='.repeat(50) + '\n\n';
                preview += `ğŸ“ URL:\n${parsed.url || 'âŒ æœªè¯†åˆ«'}\n\n`;
                
                if (parsed.headers.length > 0) {
                    preview += `ğŸ“‹ è¯·æ±‚å¤´ (${parsed.headers.length}):\n`;
                    parsed.headers.forEach(h => {
                        preview += `  â€¢ ${h.name}: ${h.value}\n`;
                    });
                    preview += '\n';
                } else {
                    preview += 'ğŸ“‹ è¯·æ±‚å¤´: æ— \n\n';
                }

                preview += 'âš ï¸ æ³¨æ„ï¼šæµè§ˆå™¨çš„ EventSource API ä¸æ”¯æŒè‡ªå®šä¹‰è¯·æ±‚å¤´ã€‚\n';
                preview += 'å¦‚éœ€è‡ªå®šä¹‰è¯·æ±‚å¤´ï¼Œè¯·è€ƒè™‘ï¼š\n';
                preview += '1. å°†è®¤è¯ä¿¡æ¯æ”¾åœ¨ URL å‚æ•°ä¸­\n';
                preview += '2. ä½¿ç”¨ Fetch API with ReadableStream\n';
                preview += '3. ä½¿ç”¨æœåŠ¡ç«¯ä»£ç†\n';
                preview += '='.repeat(50);

                document.getElementById('sseCurlPreviewContent').textContent = preview;
                document.getElementById('sseCurlPreview').style.display = 'block';

            } catch (error) {
                alert('âŒ è§£æå¤±è´¥ï¼š' + error.message);
                console.error('é¢„è§ˆé”™è¯¯ï¼š', error);
            }
        }

        function importSSECurl() {
            const curlInput = document.getElementById('sseCurlInput').value.trim();

            if (!curlInput) {
                alert('è¯·ç²˜è´´cURLå‘½ä»¤æˆ–URL');
                return;
            }

            try {
                const parsed = parseCurlCommand(curlInput);

                if (parsed.url) {
                    document.getElementById('sseUrl').value = parsed.url;
                } else {
                    alert('âš ï¸ æ— æ³•æå–URLï¼Œè¯·æ£€æŸ¥æ ¼å¼');
                    return;
                }

                // å¡«å……è¯·æ±‚å¤´ï¼ˆè™½ç„¶EventSourceä¸æ”¯æŒï¼Œä½†ä¿ç•™ä»¥ä¾¿ç”¨æˆ·äº†è§£ï¼‰
                const headerContainer = document.getElementById('sseHeaders');
                if (parsed.headers.length > 0) {
                    headerContainer.innerHTML = '';
                    parsed.headers.forEach(header => {
                        const row = document.createElement('div');
                        row.className = 'header-row';
                        row.innerHTML = `
                            <input type="text" placeholder="Header Name" value="${escapeHtml(header.name)}">
                            <input type="text" placeholder="Header Value" value="${escapeHtml(header.value)}">
                            <button class="button-remove" onclick="removeHeader(this)">åˆ é™¤</button>
                        `;
                        headerContainer.appendChild(row);
                    });
                }

                // å…³é—­å¯¼å…¥é¢æ¿
                toggleSSECurlImport();
                document.getElementById('sseCurlInput').value = '';
                document.getElementById('sseCurlPreview').style.display = 'none';

                let importDetails = 'âœ… SSE URL å¯¼å…¥æˆåŠŸï¼\n\n';
                importDetails += `ğŸ“ URL: ${parsed.url}\n`;
                importDetails += `ğŸ“‹ è¯·æ±‚å¤´: ${parsed.headers.length} ä¸ª\n\n`;
                
                if (parsed.headers.length > 0) {
                    importDetails += 'âš ï¸ æ³¨æ„ï¼šEventSource API ä¸æ”¯æŒè‡ªå®šä¹‰è¯·æ±‚å¤´ã€‚\n';
                    importDetails += 'å»ºè®®å°†è®¤è¯ä¿¡æ¯ç­‰é€šè¿‡ URL å‚æ•°ä¼ é€’ã€‚';
                }
                
                alert(importDetails);

            } catch (error) {
                alert('âŒ è§£æå¤±è´¥ï¼š' + error.message);
                console.error('SSE cURLè§£æé”™è¯¯ï¼š', error);
            }
        }

        // WebSocket URL/cURL å¯¼å…¥åŠŸèƒ½
        function toggleWSCurlImport() {
            const section = document.getElementById('wsCurlImportSection');
            section.style.display = section.style.display === 'none' ? 'block' : 'none';
            if (section.style.display === 'block') {
                document.getElementById('wsCurlInput').focus();
            }
        }

        function previewWSCurl() {
            const input = document.getElementById('wsCurlInput').value.trim();

            if (!input) {
                alert('è¯·å…ˆç²˜è´´URLæˆ–cURLå‘½ä»¤');
                return;
            }

            try {
                let wsUrl = '';
                let allHeaders = [];
                let standardHeaders = [];
                let customHeaders = [];
                
                // WebSocketæ ‡å‡†æ¡æ‰‹å¤´
                const standardWSHeaderNames = [
                    'upgrade',
                    'connection',
                    'sec-websocket-key',
                    'sec-websocket-version',
                    'sec-websocket-extensions',
                    'sec-websocket-protocol',
                    'host',
                    'origin',
                    'user-agent',
                    'accept-encoding',
                    'accept-language',
                    'cache-control',
                    'pragma'
                ];

                // åˆ¤æ–­æ˜¯ç›´æ¥URLè¿˜æ˜¯cURLå‘½ä»¤
                if (input.startsWith('ws://') || input.startsWith('wss://')) {
                    wsUrl = input;
                } else if (input.includes('curl')) {
                    const parsed = parseCurlCommand(input);
                    if (parsed.url) {
                        wsUrl = parsed.url.replace(/^http:/, 'ws:').replace(/^https:/, 'wss:');
                        allHeaders = parsed.headers;
                        
                        // åˆ†ç±»è¯·æ±‚å¤´
                        allHeaders.forEach(h => {
                            const headerName = h.name.toLowerCase();
                            if (standardWSHeaderNames.includes(headerName)) {
                                standardHeaders.push(h);
                            } else {
                                customHeaders.push(h);
                            }
                        });
                    }
                } else {
                    wsUrl = input.replace(/^http:/, 'ws:').replace(/^https:/, 'wss:');
                }

                let preview = 'ğŸ” WebSocket URL è§£æé¢„è§ˆ\n';
                preview += '='.repeat(50) + '\n\n';
                preview += `ğŸ“ WebSocket URL:\n${wsUrl}\n\n`;

                try {
                    const urlObj = new URL(wsUrl);
                    if (urlObj.search) {
                        preview += `ğŸ”— å½“å‰URLå‚æ•° (${urlObj.searchParams.size}):\n`;
                        urlObj.searchParams.forEach((value, key) => {
                            preview += `  â€¢ ${key} = ${value}\n`;
                        });
                        preview += '\n';
                    }
                    preview += `ğŸŒ åè®®: ${urlObj.protocol}\n`;
                    preview += `ğŸ  ä¸»æœº: ${urlObj.host}\n`;
                    preview += `ğŸ“‚ è·¯å¾„: ${urlObj.pathname}\n\n`;
                } catch (e) {
                    preview += 'âš ï¸ URLæ ¼å¼å¯èƒ½ä¸æ­£ç¡®\n\n';
                }

                // æ˜¾ç¤ºæ ‡å‡†è¯·æ±‚å¤´
                if (standardHeaders.length > 0) {
                    preview += `âœ“ æ ‡å‡†WebSocketæ¡æ‰‹å¤´ (${standardHeaders.length}ä¸ªï¼Œå°†è‡ªåŠ¨è¿‡æ»¤):\n`;
                    standardHeaders.forEach(h => {
                        preview += `  â€¢ ${h.name}: ${h.value.substring(0, 50)}${h.value.length > 50 ? '...' : ''}\n`;
                    });
                    preview += '\n';
                }

                // æ˜¾ç¤ºè‡ªå®šä¹‰è¯·æ±‚å¤´
                if (customHeaders.length > 0) {
                    preview += `âš ï¸ è‡ªå®šä¹‰è¯·æ±‚å¤´ (${customHeaders.length}ä¸ªï¼Œéœ€è¦ç‰¹æ®Šå¤„ç†):\n`;
                    customHeaders.forEach(h => {
                        preview += `  â€¢ ${h.name}: ${h.value}\n`;
                    });
                    preview += '\nğŸ’¡ è¿™äº›å¤´æ— æ³•é€šè¿‡WebSocketæ¡æ‰‹å‘é€ï¼Œå»ºè®®ï¼š\n';
                    preview += '  1. ä½œä¸ºURLå‚æ•°ä¼ é€’ï¼ˆå¯¼å…¥æ—¶ä¼šè¯¢é—®ï¼‰\n';
                    preview += '  2. è¿æ¥æˆåŠŸåé€šè¿‡æ¶ˆæ¯å‘é€\n';
                    preview += '  3. ä½¿ç”¨å­åè®®ï¼ˆSec-WebSocket-Protocolï¼‰\n\n';
                } else if (allHeaders.length > 0) {
                    preview += 'âœ“ æ‰€æœ‰è¯·æ±‚å¤´éƒ½æ˜¯æ ‡å‡†æ¡æ‰‹å¤´ï¼Œå°†è‡ªåŠ¨å¤„ç†\n\n';
                }

                preview += 'ğŸ“ æ€»ç»“:\n';
                preview += `  â€¢ æ ‡å‡†å¤´: ${standardHeaders.length} ä¸ªï¼ˆè‡ªåŠ¨è¿‡æ»¤ï¼‰\n`;
                preview += `  â€¢ è‡ªå®šä¹‰å¤´: ${customHeaders.length} ä¸ªï¼ˆéœ€è¦å¤„ç†ï¼‰\n`;
                preview += `  â€¢ æœ€ç»ˆURL: ${wsUrl}\n\n`;

                preview += 'âš ï¸ é‡è¦æç¤ºï¼š\n';
                preview += '1. WebSocketæ¡æ‰‹ç”±æµè§ˆå™¨è‡ªåŠ¨å¤„ç†æ ‡å‡†å¤´\n';
                preview += '2. æ— æ³•åœ¨æ¡æ‰‹æ—¶å‘é€è‡ªå®šä¹‰HTTPå¤´ï¼ˆæµè§ˆå™¨é™åˆ¶ï¼‰\n';
                preview += '3. è®¤è¯ä¿¡æ¯å»ºè®®é€šè¿‡URLå‚æ•°æˆ–è¿æ¥åçš„æ¶ˆæ¯ä¼ é€’\n';
                preview += '='.repeat(50);

                document.getElementById('wsCurlPreviewContent').textContent = preview;
                document.getElementById('wsCurlPreview').style.display = 'block';

            } catch (error) {
                alert('âŒ è§£æå¤±è´¥ï¼š' + error.message);
                console.error('é¢„è§ˆé”™è¯¯ï¼š', error);
            }
        }

        function importWSCurl() {
            const input = document.getElementById('wsCurlInput').value.trim();

            if (!input) {
                alert('è¯·ç²˜è´´URLæˆ–cURLå‘½ä»¤');
                return;
            }

            try {
                let wsUrl = '';
                let customHeaders = [];
                
                // WebSocketæ ‡å‡†æ¡æ‰‹å¤´ï¼ˆæµè§ˆå™¨è‡ªåŠ¨å¤„ç†ï¼Œä¸åº”ä½œä¸ºURLå‚æ•°ï¼‰
                const standardWSHeaders = [
                    'upgrade',
                    'connection',
                    'sec-websocket-key',
                    'sec-websocket-version',
                    'sec-websocket-extensions',
                    'sec-websocket-protocol',
                    'host',
                    'origin', // Originé€šå¸¸ç”±æµè§ˆå™¨è‡ªåŠ¨è®¾ç½®
                    'user-agent',
                    'accept-encoding',
                    'accept-language',
                    'cache-control',
                    'pragma'
                ];

                // åˆ¤æ–­æ˜¯ç›´æ¥URLè¿˜æ˜¯cURLå‘½ä»¤
                if (input.startsWith('ws://') || input.startsWith('wss://')) {
                    wsUrl = input;
                } else if (input.includes('curl')) {
                    const parsed = parseCurlCommand(input);
                    if (parsed.url) {
                        wsUrl = parsed.url.replace(/^http:/, 'ws:').replace(/^https:/, 'wss:');
                        
                        // è¿‡æ»¤å‡ºéæ ‡å‡†çš„è‡ªå®šä¹‰è¯·æ±‚å¤´
                        if (parsed.headers.length > 0) {
                            parsed.headers.forEach(h => {
                                const headerName = h.name.toLowerCase();
                                if (!standardWSHeaders.includes(headerName)) {
                                    customHeaders.push(h);
                                }
                            });
                        }
                    }
                } else {
                    wsUrl = input.replace(/^http:/, 'ws:').replace(/^https:/, 'wss:');
                }

                if (!wsUrl) {
                    alert('âŒ æ— æ³•æå–æœ‰æ•ˆçš„ URL');
                    return;
                }

                // å¦‚æœæœ‰è‡ªå®šä¹‰è¯·æ±‚å¤´ï¼Œè¯¢é—®æ˜¯å¦æ·»åŠ åˆ°URL
                if (customHeaders.length > 0) {
                    let confirmMessage = 'æ£€æµ‹åˆ°è‡ªå®šä¹‰è¯·æ±‚å¤´ï¼ŒWebSocketæ¡æ‰‹ä¸æ”¯æŒè¿™äº›å¤´ã€‚\n\n';
                    confirmMessage += 'æ˜¯å¦å°†å®ƒä»¬ä½œä¸ºURLå‚æ•°æ·»åŠ ï¼Ÿ\n\n';
                    confirmMessage += 'è‡ªå®šä¹‰è¯·æ±‚å¤´ï¼š\n';
                    customHeaders.forEach(h => {
                        confirmMessage += `  â€¢ ${h.name}: ${h.value}\n`;
                    });
                    confirmMessage += '\næ³¨æ„ï¼šå·²è‡ªåŠ¨è¿‡æ»¤æ‰æ ‡å‡†WebSocketæ¡æ‰‹å¤´ã€‚';
                    
                    const addParams = confirm(confirmMessage);
                    
                    if (addParams) {
                        const params = customHeaders.map(h => 
                            `${encodeURIComponent(h.name)}=${encodeURIComponent(h.value)}`
                        );
                        const separator = wsUrl.includes('?') ? '&' : '?';
                        wsUrl += separator + params.join('&');
                    }
                }

                document.getElementById('wsUrl').value = wsUrl;

                // å…³é—­å¯¼å…¥é¢æ¿
                toggleWSCurlImport();
                document.getElementById('wsCurlInput').value = '';
                document.getElementById('wsCurlPreview').style.display = 'none';

                let resultMessage = 'âœ… WebSocket URL å¯¼å…¥æˆåŠŸï¼\n\n';
                resultMessage += `ğŸ“ URL: ${wsUrl}\n\n`;
                
                if (customHeaders.length === 0) {
                    resultMessage += 'âœ“ å·²è¿‡æ»¤æ‰€æœ‰æ ‡å‡†WebSocketæ¡æ‰‹å¤´\n';
                    resultMessage += 'âœ“ URLä¸­åªä¿ç•™åŸæœ‰çš„æŸ¥è¯¢å‚æ•°';
                } else {
                    resultMessage += `âœ“ å·²è¿‡æ»¤æ ‡å‡†æ¡æ‰‹å¤´\n`;
                    resultMessage += `âœ“ æ£€æµ‹åˆ° ${customHeaders.length} ä¸ªè‡ªå®šä¹‰è¯·æ±‚å¤´`;
                }

                alert(resultMessage);

            } catch (error) {
                alert('âŒ å¯¼å…¥å¤±è´¥ï¼š' + error.message);
                console.error('WebSocketå¯¼å…¥é”™è¯¯ï¼š', error);
            }
        }

        // SSEè¿æ¥
        async function connectSSE() {
            const url = document.getElementById('sseUrl').value;

            if (!url) {
                alert('è¯·è¾“å…¥SSE URL');
                return;
            }

            if (sseConnection) {
                if (sseConnection.close) {
                    sseConnection.close();
                }
                if (sseConnection.abort) {
                    sseConnection.abort();
                }
            }

            // è®¾ç½®æŒ‰é’®çŠ¶æ€
            const connectBtn = document.getElementById('sseConnectBtn');
            const disconnectBtn = document.getElementById('sseDisconnectBtn');
            connectBtn.classList.add('button-loading');
            connectBtn.textContent = 'è¿æ¥ä¸­...';
            connectBtn.disabled = true;

            // æ”¶é›†è¯·æ±‚å¤´
            const headers = {};
            const headerRows = document.querySelectorAll('#sseHeaders .header-row');
            headerRows.forEach(row => {
                const inputs = row.querySelectorAll('input');
                const name = inputs[0].value.trim();
                const value = inputs[1].value.trim();
                if (name) {
                    headers[name] = value;
                }
            });

            logSSEEvent('info', 'æ­£åœ¨è¿æ¥åˆ° ' + url);

            // æ£€æŸ¥æ˜¯å¦æœ‰è‡ªå®šä¹‰è¯·æ±‚å¤´
            const hasCustomHeaders = Object.keys(headers).length > 0;

            if (hasCustomHeaders) {
                // ä½¿ç”¨ Fetch API with ReadableStream æ”¯æŒè‡ªå®šä¹‰è¯·æ±‚å¤´
                try {
                    const response = await fetch(url, {
                        method: 'GET',
                        headers: headers
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    // æ£€æŸ¥æ˜¯å¦æ˜¯SSEå“åº”
                    const contentType = response.headers.get('content-type');
                    if (!contentType || !contentType.includes('text/event-stream')) {
                        logSSEEvent('warning', 'âš ï¸ è­¦å‘Š: Content-Type ä¸æ˜¯ text/event-streamï¼Œå¯èƒ½ä¸æ˜¯æœ‰æ•ˆçš„SSEç«¯ç‚¹');
                    }

                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    
                    // ä¿å­˜readerç”¨äºæ–­å¼€è¿æ¥
                    sseConnection = { reader, abort: () => reader.cancel() };

                    // æ›´æ–°çŠ¶æ€
                    document.getElementById('sseStatus').textContent = 'å·²è¿æ¥';
                    document.getElementById('sseStatus').className = 'ws-status connected';
                    connectBtn.classList.remove('button-loading');
                    connectBtn.textContent = 'è¿æ¥';
                    connectBtn.disabled = true;
                    disconnectBtn.disabled = false;
                    
                    logSSEEvent('success', 'âœ… è¿æ¥æˆåŠŸï¼ˆä½¿ç”¨ Fetch API + ReadableStreamï¼‰');

                    // è¯»å–æµæ•°æ®
                    let buffer = '';
                    let currentEvent = {
                        data: [],
                        event: '',
                        id: '',
                        retry: null
                    };
                    
                    async function readStream() {
                        try {
                            while (true) {
                                const { done, value } = await reader.read();
                                
                                if (done) {
                                    logSSEEvent('info', 'ğŸ”Œ æµå·²ç»“æŸ');
                                    disconnectSSE();
                                    break;
                                }

                                const chunk = decoder.decode(value, { stream: true });
                                buffer += chunk;
                                
                                // è°ƒè¯•æ¨¡å¼ï¼šæ˜¾ç¤ºåŸå§‹æ•°æ®å—
                                if (sseDebugMode && chunk.trim()) {
                                    logSSEEvent('info', 'ğŸ” [RAW] ' + chunk.replace(/\n/g, '\\n').replace(/\r/g, '\\r'));
                                }
                                
                                const lines = buffer.split('\n');
                                buffer = lines.pop() || '';

                                for (const line of lines) {
                                    // å¤„ç†å›è½¦ç¬¦
                                    const cleanLine = line.replace(/\r$/, '');
                                    
                                    // è°ƒè¯•æ¨¡å¼ï¼šæ˜¾ç¤ºè§£æçš„æ¯ä¸€è¡Œ
                                    if (sseDebugMode && line) {
                                        logSSEEvent('info', `ğŸ” [LINE] "${cleanLine}"`);
                                    }
                                    
                                    if (cleanLine === '') {
                                        // ç©ºè¡Œè¡¨ç¤ºæ¶ˆæ¯ç»“æŸï¼Œè§¦å‘äº‹ä»¶
                                        if (currentEvent.data.length > 0) {
                                            const messageData = currentEvent.data.join('\n');
                                            const eventType = currentEvent.event || 'message';
                                            
                                            // è°ƒè¯•æ¨¡å¼ï¼šæ˜¾ç¤ºå®Œæ•´äº‹ä»¶å¯¹è±¡
                                            if (sseDebugMode) {
                                                logSSEEvent('info', 'ğŸ” [EVENT] ' + JSON.stringify({
                                                    type: eventType,
                                                    data: messageData,
                                                    id: currentEvent.id || null
                                                }));
                                            }
                                            
                                            if (eventType === 'message') {
                                                logSSEEvent('message', 'ğŸ“¨ æ”¶åˆ°æ¶ˆæ¯: ' + messageData);
                                            } else {
                                                logSSEEvent('custom', `ğŸ“¡ [${eventType}] ` + messageData);
                                            }
                                            
                                            if (currentEvent.id && !sseDebugMode) {
                                                logSSEEvent('info', '  â””â”€ ID: ' + currentEvent.id);
                                            }
                                        }
                                        
                                        // é‡ç½®å½“å‰äº‹ä»¶ï¼ˆä¿ç•™retryï¼‰
                                        const retry = currentEvent.retry;
                                        currentEvent = {
                                            data: [],
                                            event: '',
                                            id: '',
                                            retry: retry
                                        };
                                    } else if (cleanLine.startsWith('data:')) {
                                        // data: åé¢å¯èƒ½æœ‰ç©ºæ ¼ï¼Œä¹Ÿå¯èƒ½æ²¡æœ‰
                                        const data = cleanLine.substring(5);
                                        currentEvent.data.push(data.startsWith(' ') ? data.substring(1) : data);
                                    } else if (cleanLine.startsWith('event:')) {
                                        const event = cleanLine.substring(6);
                                        currentEvent.event = event.startsWith(' ') ? event.substring(1) : event;
                                    } else if (cleanLine.startsWith('id:')) {
                                        const id = cleanLine.substring(3);
                                        currentEvent.id = id.startsWith(' ') ? id.substring(1) : id;
                                    } else if (cleanLine.startsWith('retry:')) {
                                        const retry = cleanLine.substring(6);
                                        const retryValue = parseInt(retry.startsWith(' ') ? retry.substring(1) : retry);
                                        if (!isNaN(retryValue)) {
                                            currentEvent.retry = retryValue;
                                            logSSEEvent('info', 'â±ï¸ é‡è¯•é—´éš”: ' + retryValue + 'ms');
                                        }
                                    } else if (cleanLine.startsWith(':')) {
                                        // æ³¨é‡Šè¡Œï¼Œå¿½ç•¥ï¼ˆç”¨äºä¿æŒè¿æ¥ï¼‰
                                        // logSSEEvent('info', 'ğŸ’¬ æ³¨é‡Š: ' + cleanLine.substring(1));
                                    } else {
                                        // æœªçŸ¥æ ¼å¼çš„è¡Œï¼Œè®°å½•ä»¥ä¾¿è°ƒè¯•
                                        if (cleanLine.trim()) {
                                            logSSEEvent('info', 'âš ï¸ æœªçŸ¥æ ¼å¼: ' + cleanLine);
                                        }
                                    }
                                }
                            }
                        } catch (error) {
                            if (error.name !== 'AbortError') {
                                logSSEEvent('error', 'âŒ è¯»å–é”™è¯¯: ' + error.message);
                                disconnectSSE();
                            }
                        }
                    }

                    readStream();

                } catch (error) {
                    logSSEEvent('error', 'âŒ è¿æ¥å¤±è´¥: ' + error.message);
                    document.getElementById('sseStatus').textContent = 'æœªè¿æ¥';
                    document.getElementById('sseStatus').className = 'ws-status disconnected';
                    connectBtn.classList.remove('button-loading');
                    connectBtn.textContent = 'è¿æ¥';
                    connectBtn.disabled = false;
                    disconnectBtn.disabled = true;
                }
            } else {
                // ä½¿ç”¨æ ‡å‡† EventSource APIï¼ˆä¸æ”¯æŒè‡ªå®šä¹‰è¯·æ±‚å¤´ï¼‰
                try {
                    sseConnection = new EventSource(url);
                    
                    sseConnection.onopen = function() {
                        logSSEEvent('success', 'âœ… è¿æ¥æˆåŠŸï¼ˆä½¿ç”¨ EventSource APIï¼‰');
                        document.getElementById('sseStatus').textContent = 'å·²è¿æ¥';
                        document.getElementById('sseStatus').className = 'ws-status connected';
                        connectBtn.classList.remove('button-loading');
                        connectBtn.textContent = 'è¿æ¥';
                        connectBtn.disabled = true;
                        disconnectBtn.disabled = false;
                    };

                    sseConnection.onmessage = function(event) {
                        logSSEEvent('message', 'ğŸ“¨ æ”¶åˆ°æ¶ˆæ¯: ' + event.data);
                    };

                    sseConnection.onerror = function(error) {
                        logSSEEvent('error', 'âŒ è¿æ¥é”™è¯¯');
                        document.getElementById('sseStatus').textContent = 'è¿æ¥é”™è¯¯';
                        document.getElementById('sseStatus').className = 'ws-status disconnected';
                        connectBtn.classList.remove('button-loading');
                        connectBtn.textContent = 'è¿æ¥';
                        connectBtn.disabled = false;
                        disconnectBtn.disabled = true;
                    };

                    // ç›‘å¬è‡ªå®šä¹‰äº‹ä»¶ç±»å‹
                    sseConnection.addEventListener('custom', function(event) {
                        logSSEEvent('custom', 'ğŸ“¡ è‡ªå®šä¹‰äº‹ä»¶: ' + event.data);
                    });

                } catch (error) {
                    logSSEEvent('error', 'âŒ è¿æ¥å¤±è´¥: ' + error.message);
                    document.getElementById('sseStatus').textContent = 'æœªè¿æ¥';
                    document.getElementById('sseStatus').className = 'ws-status disconnected';
                    connectBtn.classList.remove('button-loading');
                    connectBtn.textContent = 'è¿æ¥';
                    connectBtn.disabled = false;
                    disconnectBtn.disabled = true;
                }
            }
        }

        function disconnectSSE() {
            if (sseConnection) {
                if (sseConnection.close) {
                    sseConnection.close();
                }
                if (sseConnection.abort) {
                    sseConnection.abort();
                }
                sseConnection = null;
                document.getElementById('sseStatus').textContent = 'æœªè¿æ¥';
                document.getElementById('sseStatus').className = 'ws-status disconnected';
                
                // æ›´æ–°æŒ‰é’®çŠ¶æ€
                const connectBtn = document.getElementById('sseConnectBtn');
                const disconnectBtn = document.getElementById('sseDisconnectBtn');
                connectBtn.disabled = false;
                disconnectBtn.disabled = true;
                
                logSSEEvent('info', 'ğŸ”Œ è¿æ¥å·²æ–­å¼€');
            }
        }

        function logSSEEvent(type, message) {
            const log = document.getElementById('sseLog');
            
            // æ¸…é™¤ç©ºçŠ¶æ€
            if (log.querySelector('.empty-state')) {
                log.innerHTML = '';
            }

            const time = new Date().toLocaleTimeString();
            const item = document.createElement('div');
            item.className = 'event-item';
            item.innerHTML = `<span class="event-time">[${time}]</span><span class="event-type">[${type.toUpperCase()}]</span><span class="event-data">${message}</span>`;
            log.appendChild(item);
            log.scrollTop = log.scrollHeight;
        }

        function clearSSELog() {
            const log = document.getElementById('sseLog');
            log.innerHTML = '<div class="empty-state"><div style="font-size: 40px; margin-bottom: 10px;">ğŸ“¡</div><p>æ—¥å¿—å·²æ¸…ç©º</p></div>';
        }

        // WebSocket è°ƒè¯•æ¨¡å¼åˆ‡æ¢
        function toggleWSDebugMode() {
            wsDebugMode = document.getElementById('wsDebugMode').checked;
            if (wsDebugMode) {
                logWSEvent('info', 'ğŸ” è°ƒè¯•æ¨¡å¼å·²å¯ç”¨ - å°†æ˜¾ç¤ºè¯¦ç»†è¿æ¥ä¿¡æ¯');
            } else {
                logWSEvent('info', 'ğŸ” è°ƒè¯•æ¨¡å¼å·²å…³é—­');
            }
        }

        // WebSocket å¤åˆ¶è¿æ¥ä¿¡æ¯
        function copyWSInfo() {
            const url = document.getElementById('wsUrl').value;
            const protocols = document.getElementById('wsProtocols').value;

            if (!url) {
                alert('è¯·å…ˆè¾“å…¥WebSocket URL');
                return;
            }

            // æ„å»ºå¤šç§æ ¼å¼çš„è¿æ¥ä¿¡æ¯
            let info = '# WebSocket è¿æ¥ä¿¡æ¯\n';
            info += 'â•'.repeat(60) + '\n\n';
            
            info += `ğŸ“ WebSocket URL:\n${url}\n\n`;
            
            if (protocols) {
                info += `ğŸ”Œ å­åè®®:\n${protocols}\n\n`;
            }

            // æå–URLä¿¡æ¯
            try {
                const urlObj = new URL(url);
                info += `ğŸŒ åè®®: ${urlObj.protocol}\n`;
                info += `ğŸ  ä¸»æœº: ${urlObj.host}\n`;
                info += `ğŸ“‚ è·¯å¾„: ${urlObj.pathname}\n`;
                if (urlObj.search) {
                    info += `ğŸ”— æŸ¥è¯¢å‚æ•°: ${urlObj.search}\n`;
                }
                info += '\n';
            } catch (e) {
                // URL æ ¼å¼é”™è¯¯ï¼Œå¿½ç•¥
            }

            info += 'â”€'.repeat(60) + '\n\n';

            // wscat å‘½ä»¤ï¼ˆNode.jså·¥å…·ï¼‰
            info += 'ğŸ’¡ ä½¿ç”¨ wscat (Node.js):\n';
            let wscatCmd = `wscat -c "${url}"`;
            if (protocols) {
                wscatCmd += ` --subprotocol "${protocols}"`;
            }
            info += wscatCmd + '\n\n';

            // websocat å‘½ä»¤ï¼ˆRustå·¥å…·ï¼‰
            info += 'ğŸ’¡ ä½¿ç”¨ websocat (Rust):\n';
            let websocatCmd = `websocat "${url}"`;
            info += websocatCmd + '\n\n';

            // curl å‘½ä»¤ï¼ˆä»…ç”¨äºæµ‹è¯•æ¡æ‰‹ï¼Œä¸æ”¯æŒå®Œæ•´WebSocketï¼‰
            info += 'ğŸ’¡ ä½¿ç”¨ curl æµ‹è¯•æ¡æ‰‹:\n';
            const httpUrl = url.replace(/^wss?:/, url.startsWith('wss:') ? 'https:' : 'http:');
            let curlCmd = `curl -i -N \\\n  -H "Connection: Upgrade" \\\n  -H "Upgrade: websocket" \\\n  -H "Sec-WebSocket-Version: 13" \\\n  -H "Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==" \\\n  "${httpUrl}"`;
            info += curlCmd + '\n\n';

            // JavaScript ä»£ç 
            info += 'ğŸ’¡ JavaScript ä»£ç :\n';
            let jsCode = protocols 
                ? `const ws = new WebSocket("${url}", "${protocols}");` 
                : `const ws = new WebSocket("${url}");`;
            jsCode += '\nws.onopen = () => console.log("Connected");';
            jsCode += '\nws.onmessage = (e) => console.log("Message:", e.data);';
            jsCode += '\nws.onerror = (e) => console.error("Error:", e);';
            jsCode += '\nws.onclose = (e) => console.log("Closed:", e.code);';
            info += jsCode + '\n\n';

            // Python ä»£ç 
            info += 'ğŸ’¡ Python ä»£ç  (websockets):\n';
            let pythonCode = 'import asyncio\nimport websockets\n\n';
            pythonCode += 'async def connect():\n';
            if (protocols) {
                pythonCode += `    async with websockets.connect("${url}", subprotocols=["${protocols}"]) as ws:\n`;
            } else {
                pythonCode += `    async with websockets.connect("${url}") as ws:\n`;
            }
            pythonCode += '        await ws.send("Hello")\n';
            pythonCode += '        response = await ws.recv()\n';
            pythonCode += '        print(response)\n\n';
            pythonCode += 'asyncio.run(connect())';
            info += pythonCode + '\n\n';

            info += 'â•'.repeat(60) + '\n';
            info += '\næ³¨æ„ï¼šWebSocket æ˜¯åŒå‘é€šä¿¡åè®®ï¼Œcurl ä¸å®Œå…¨æ”¯æŒã€‚\n';
            info += 'æ¨èä½¿ç”¨ wscatã€websocat æˆ–ç¼–ç¨‹è¯­è¨€çš„ WebSocket åº“ã€‚';

            // å¤åˆ¶åˆ°å‰ªè´´æ¿
            navigator.clipboard.writeText(info).then(() => {
                const btn = event.target;
                const originalText = btn.textContent;
                btn.textContent = 'âœ… å·²å¤åˆ¶';
                btn.style.background = '#4caf50';
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.background = '';
                }, 2000);
            }).catch(err => {
                alert('å¤åˆ¶å¤±è´¥ï¼š' + err.message + '\n\nä¿¡æ¯å·²ç”Ÿæˆï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶ï¼š\n\n' + info);
            });
        }

        // WebSocketå¿ƒè·³ç›¸å…³å‡½æ•°
        function startHeartbeat() {
            const enabled = document.getElementById('wsHeartbeatEnabled').checked;
            if (!enabled || !wsConnection || wsConnection.readyState !== WebSocket.OPEN) {
                return;
            }

            stopHeartbeat();

            const interval = parseInt(document.getElementById('wsHeartbeatInterval').value) * 1000;
            const message = document.getElementById('wsHeartbeatMessage').value;
            const timeout = parseInt(document.getElementById('wsHeartbeatTimeout').value) * 1000;
            const autoReconnect = document.getElementById('wsAutoReconnect').checked;

            wsLastMessageTime = Date.now();

            // å¿ƒè·³å®šæ—¶å™¨
            wsHeartbeatTimer = setInterval(() => {
                if (wsConnection && wsConnection.readyState === WebSocket.OPEN) {
                    try {
                        wsConnection.send(message);
                        if (wsDebugMode) {
                            logWSEvent('info', `ğŸ’“ [HEARTBEAT] å‘é€å¿ƒè·³: ${message}`);
                        }
                    } catch (error) {
                        logWSEvent('error', 'ğŸ’“ [HEARTBEAT] å‘é€å¿ƒè·³å¤±è´¥: ' + error.message);
                    }
                } else {
                    stopHeartbeat();
                }
            }, interval);

            // è¶…æ—¶æ£€æµ‹å®šæ—¶å™¨
            wsHeartbeatTimeoutTimer = setInterval(() => {
                const timeSinceLastMessage = Date.now() - wsLastMessageTime;
                
                if (timeSinceLastMessage > timeout) {
                    logWSEvent('error', 'ğŸ’“ [HEARTBEAT] è¿æ¥è¶…æ—¶ï¼è¶…è¿‡ ' + (timeout/1000) + ' ç§’æœªæ”¶åˆ°æ¶ˆæ¯');
                    
                    if (autoReconnect) {
                        logWSEvent('info', 'ğŸ’“ [HEARTBEAT] å°è¯•è‡ªåŠ¨é‡è¿...');
                        const url = document.getElementById('wsUrl').value;
                        setTimeout(() => {
                            if (wsConnection) {
                                wsConnection.close();
                            }
                            connectWebSocket();
                        }, 1000);
                    } else {
                        if (wsConnection) {
                            wsConnection.close();
                        }
                    }
                    
                    stopHeartbeat();
                }
            }, 1000); // æ¯ç§’æ£€æŸ¥ä¸€æ¬¡

            logWSEvent('info', `ğŸ’“ [HEARTBEAT] å·²å¯åŠ¨å¿ƒè·³æ£€æµ‹ (é—´éš”: ${interval/1000}ç§’, è¶…æ—¶: ${timeout/1000}ç§’)`);
        }

        function stopHeartbeat() {
            if (wsHeartbeatTimer) {
                clearInterval(wsHeartbeatTimer);
                wsHeartbeatTimer = null;
            }
            if (wsHeartbeatTimeoutTimer) {
                clearInterval(wsHeartbeatTimeoutTimer);
                wsHeartbeatTimeoutTimer = null;
            }
        }

        function updateLastMessageTime() {
            wsLastMessageTime = Date.now();
        }

        // WebSocketè¿æ¥
        function connectWebSocket() {
            const url = document.getElementById('wsUrl').value;
            const protocols = document.getElementById('wsProtocols').value.split(',').map(p => p.trim()).filter(p => p);

            if (!url) {
                alert('è¯·è¾“å…¥WebSocket URL');
                return;
            }

            if (wsConnection) {
                wsConnection.close();
            }

            // è®¾ç½®æŒ‰é’®çŠ¶æ€
            const connectBtn = document.getElementById('wsConnectBtn');
            const disconnectBtn = document.getElementById('wsDisconnectBtn');
            connectBtn.classList.add('button-loading');
            connectBtn.textContent = 'è¿æ¥ä¸­...';
            connectBtn.disabled = true;

            // è°ƒè¯•ä¿¡æ¯ï¼šè¿æ¥å‚æ•°
            logWSEvent('info', 'æ­£åœ¨è¿æ¥åˆ° ' + url);
            
            if (wsDebugMode) {
                try {
                    const urlObj = new URL(url);
                    logWSEvent('info', 'ğŸ” [DEBUG] åè®®: ' + urlObj.protocol);
                    logWSEvent('info', 'ğŸ” [DEBUG] ä¸»æœº: ' + urlObj.host);
                    logWSEvent('info', 'ğŸ” [DEBUG] è·¯å¾„: ' + urlObj.pathname);
                    if (urlObj.search) {
                        logWSEvent('info', 'ğŸ” [DEBUG] æŸ¥è¯¢å‚æ•°: ' + urlObj.search);
                    }
                    if (protocols.length > 0) {
                        logWSEvent('info', 'ğŸ” [DEBUG] å­åè®®: ' + protocols.join(', '));
                    }
                } catch (e) {
                    logWSEvent('error', 'ğŸ” [DEBUG] URLè§£æå¤±è´¥: ' + e.message);
                }
            }

            try {
                const startTime = Date.now();
                wsConnection = protocols.length > 0 ? new WebSocket(url, protocols) : new WebSocket(url);
                
                // è®°å½•readyState
                if (wsDebugMode) {
                    logWSEvent('info', 'ğŸ” [DEBUG] åˆå§‹çŠ¶æ€: CONNECTING (' + wsConnection.readyState + ')');
                }

                wsConnection.onopen = function(event) {
                    const connectTime = Date.now() - startTime;
                    logWSEvent('success', 'âœ… WebSocketè¿æ¥æˆåŠŸ (' + connectTime + 'ms)');
                    document.getElementById('wsStatus').textContent = 'å·²è¿æ¥';
                    document.getElementById('wsStatus').className = 'ws-status connected';
                    
                    if (wsDebugMode) {
                        logWSEvent('info', 'ğŸ” [DEBUG] readyState: OPEN (' + wsConnection.readyState + ')');
                        logWSEvent('info', 'ğŸ” [DEBUG] åè®®: ' + (wsConnection.protocol || '(æ— )'));
                        logWSEvent('info', 'ğŸ” [DEBUG] æ‰©å±•: ' + (wsConnection.extensions || '(æ— )'));
                        logWSEvent('info', 'ğŸ” [DEBUG] bufferedAmount: ' + wsConnection.bufferedAmount);
                    }
                    
                    // å‘é€è‡ªå®šä¹‰è¯·æ±‚å¤´ï¼ˆä½œä¸ºé¦–æ¡æ¶ˆæ¯ï¼‰
                    const headers = {};
                    const headerRows = document.querySelectorAll('#wsHeaders .header-row');
                    headerRows.forEach(row => {
                        const inputs = row.querySelectorAll('input');
                        const name = inputs[0].value.trim();
                        const value = inputs[1].value.trim();
                        if (name) {
                            headers[name] = value;
                        }
                    });
                    
                    if (Object.keys(headers).length > 0) {
                        const headerMessage = JSON.stringify({
                            type: '__headers__',
                            headers: headers
                        });
                        try {
                            wsConnection.send(headerMessage);
                            logWSEvent('info', 'ğŸ“‹ [HEADERS] å·²å‘é€è‡ªå®šä¹‰è¯·æ±‚å¤´: ' + JSON.stringify(headers, null, 2));
                        } catch (error) {
                            logWSEvent('error', 'ğŸ“‹ [HEADERS] å‘é€å¤±è´¥: ' + error.message);
                        }
                    }
                    
                    // å¯åŠ¨å¿ƒè·³æ£€æµ‹
                    startHeartbeat();
                    
                    // æ›´æ–°æŒ‰é’®çŠ¶æ€
                    connectBtn.classList.remove('button-loading');
                    connectBtn.textContent = 'è¿æ¥';
                    connectBtn.disabled = true;
                    disconnectBtn.disabled = false;
                };

                wsConnection.onmessage = function(event) {
                    // æ›´æ–°æœ€åæ¶ˆæ¯æ—¶é—´ï¼ˆç”¨äºå¿ƒè·³æ£€æµ‹ï¼‰
                    updateLastMessageTime();
                    
                    if (wsDebugMode) {
                        const dataType = typeof event.data;
                        const dataSize = event.data.length || event.data.size || 0;
                        logWSEvent('info', `ğŸ” [DEBUG] æ¶ˆæ¯ç±»å‹: ${dataType}, å¤§å°: ${dataSize} bytes`);
                    }
                    logWSEvent('message', 'ğŸ“¨ æ”¶åˆ°æ¶ˆæ¯: ' + event.data);
                };

                wsConnection.onerror = function(error) {
                    // åœæ­¢å¿ƒè·³
                    stopHeartbeat();
                    
                    logWSEvent('error', 'âŒ WebSocketé”™è¯¯');
                    
                    if (wsDebugMode) {
                        logWSEvent('error', 'ğŸ” [DEBUG] readyState: ' + wsConnection.readyState);
                        logWSEvent('error', 'ğŸ” [DEBUG] Errorå¯¹è±¡: ' + JSON.stringify(error, Object.getOwnPropertyNames(error)));
                    }
                    
                    // å¸¸è§é”™è¯¯æç¤º
                    logWSEvent('info', 'ğŸ’¡ å¸¸è§é”™è¯¯åŸå› :');
                    logWSEvent('info', '  1. æœåŠ¡å™¨æ‹’ç»è¿æ¥ï¼ˆæ£€æŸ¥URLå’Œè®¤è¯ï¼‰');
                    logWSEvent('info', '  2. ç½‘ç»œé—®é¢˜æˆ–CORSé™åˆ¶');
                    logWSEvent('info', '  3. æœåŠ¡å™¨ä¸æ”¯æŒWebSocketåè®®');
                    logWSEvent('info', '  4. SSL/TLSè¯ä¹¦é—®é¢˜ï¼ˆwss://ï¼‰');
                    
                    document.getElementById('wsStatus').textContent = 'è¿æ¥é”™è¯¯';
                    document.getElementById('wsStatus').className = 'ws-status disconnected';
                    
                    // æ¢å¤æŒ‰é’®çŠ¶æ€
                    connectBtn.classList.remove('button-loading');
                    connectBtn.textContent = 'è¿æ¥';
                    connectBtn.disabled = false;
                    disconnectBtn.disabled = true;
                };

                wsConnection.onclose = function(event) {
                    // åœæ­¢å¿ƒè·³
                    stopHeartbeat();
                    
                    const closeInfo = getWebSocketCloseInfo(event.code);
                    
                    logWSEvent('info', 'ğŸ”Œ WebSocketè¿æ¥å…³é—­');
                    logWSEvent('info', `  â””â”€ å…³é—­ç : ${event.code} (${closeInfo.name})`);
                    logWSEvent('info', `  â””â”€ åŸå› : ${event.reason || '(æ— )'}`);
                    logWSEvent('info', `  â””â”€ å¹²å‡€å…³é—­: ${event.wasClean ? 'æ˜¯' : 'å¦'}`);
                    
                    if (wsDebugMode) {
                        logWSEvent('info', 'ğŸ” [DEBUG] å®Œæ•´å…³é—­äº‹ä»¶: ' + JSON.stringify({
                            code: event.code,
                            reason: event.reason,
                            wasClean: event.wasClean,
                            description: closeInfo.description
                        }, null, 2));
                    }
                    
                    // ç‰¹æ®Šé”™è¯¯ç çš„è¯¦ç»†è¯´æ˜
                    if (event.code === 1006) {
                        logWSEvent('error', 'âš ï¸ é”™è¯¯ 1006: è¿æ¥å¼‚å¸¸å…³é—­ï¼ˆæœªå®Œæˆæ¡æ‰‹ï¼‰');
                        logWSEvent('info', 'ğŸ’¡ å¯èƒ½çš„åŸå› :');
                        logWSEvent('info', '  1. æœåŠ¡å™¨æœªå“åº”æˆ–æ‹’ç»è¿æ¥');
                        logWSEvent('info', '  2. URLé”™è¯¯æˆ–æœåŠ¡å™¨ä¸å­˜åœ¨');
                        logWSEvent('info', '  3. ç½‘ç»œä¸­æ–­æˆ–é˜²ç«å¢™é˜»æ­¢');
                        logWSEvent('info', '  4. éœ€è¦è®¤è¯ä½†æœªæä¾›ï¼ˆæ£€æŸ¥URLå‚æ•°ï¼‰');
                        logWSEvent('info', 'ğŸ’¡ å»ºè®®:');
                        logWSEvent('info', '  â€¢ åœ¨æµè§ˆå™¨å¼€å‘è€…å·¥å…·çš„Networkæ ‡ç­¾æŸ¥çœ‹æ¡æ‰‹è¯·æ±‚');
                        logWSEvent('info', '  â€¢ æ£€æŸ¥æ˜¯å¦éœ€è¦è®¤è¯tokenä½œä¸ºURLå‚æ•°');
                        logWSEvent('info', '  â€¢ ç¡®è®¤æœåŠ¡å™¨WebSocketç«¯ç‚¹æ˜¯å¦æ­£ç¡®');
                    } else if (event.code === 1000) {
                        logWSEvent('success', 'âœ… æ­£å¸¸å…³é—­è¿æ¥');
                    } else if (event.code >= 4000) {
                        logWSEvent('info', 'ğŸ’¡ è¿™æ˜¯åº”ç”¨è‡ªå®šä¹‰çš„å…³é—­ç ï¼Œè¯·æŸ¥çœ‹æœåŠ¡å™¨æ–‡æ¡£');
                    }
                    
                    document.getElementById('wsStatus').textContent = 'æœªè¿æ¥';
                    document.getElementById('wsStatus').className = 'ws-status disconnected';
                    
                    // æ¢å¤æŒ‰é’®çŠ¶æ€
                    connectBtn.classList.remove('button-loading');
                    connectBtn.textContent = 'è¿æ¥';
                    connectBtn.disabled = false;
                    disconnectBtn.disabled = true;
                };

            } catch (error) {
                logWSEvent('error', 'âŒ è¿æ¥å¤±è´¥: ' + error.message);
                
                if (wsDebugMode) {
                    logWSEvent('error', 'ğŸ” [DEBUG] å¼‚å¸¸å †æ ˆ: ' + error.stack);
                }
                
                document.getElementById('wsStatus').textContent = 'æœªè¿æ¥';
                document.getElementById('wsStatus').className = 'ws-status disconnected';
                
                // æ¢å¤æŒ‰é’®çŠ¶æ€
                connectBtn.classList.remove('button-loading');
                connectBtn.textContent = 'è¿æ¥';
                connectBtn.disabled = false;
                disconnectBtn.disabled = true;
            }
        }

        // WebSocketå…³é—­ç ä¿¡æ¯
        function getWebSocketCloseInfo(code) {
            const closeCodes = {
                1000: { name: 'CLOSE_NORMAL', description: 'æ­£å¸¸å…³é—­è¿æ¥' },
                1001: { name: 'CLOSE_GOING_AWAY', description: 'ç«¯ç‚¹ç¦»å¼€ï¼ˆå¦‚é¡µé¢å…³é—­ï¼‰' },
                1002: { name: 'CLOSE_PROTOCOL_ERROR', description: 'åè®®é”™è¯¯' },
                1003: { name: 'CLOSE_UNSUPPORTED', description: 'ä¸æ”¯æŒçš„æ•°æ®ç±»å‹' },
                1004: { name: 'CLOSE_RESERVED', description: 'ä¿ç•™' },
                1005: { name: 'CLOSED_NO_STATUS', description: 'æ²¡æœ‰æ”¶åˆ°çŠ¶æ€ç ' },
                1006: { name: 'CLOSE_ABNORMAL', description: 'å¼‚å¸¸å…³é—­ï¼ˆæœªå®Œæˆæ¡æ‰‹ï¼‰' },
                1007: { name: 'UNSUPPORTED_DATA', description: 'æ•°æ®æ ¼å¼é”™è¯¯' },
                1008: { name: 'POLICY_VIOLATION', description: 'è¿åç­–ç•¥' },
                1009: { name: 'CLOSE_TOO_LARGE', description: 'æ¶ˆæ¯è¿‡å¤§' },
                1010: { name: 'MISSING_EXTENSION', description: 'ç¼ºå°‘æ‰©å±•' },
                1011: { name: 'INTERNAL_ERROR', description: 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯' },
                1012: { name: 'SERVICE_RESTART', description: 'æœåŠ¡é‡å¯' },
                1013: { name: 'TRY_AGAIN_LATER', description: 'ç¨åé‡è¯•' },
                1014: { name: 'BAD_GATEWAY', description: 'ç½‘å…³é”™è¯¯' },
                1015: { name: 'TLS_HANDSHAKE_FAIL', description: 'TLSæ¡æ‰‹å¤±è´¥' }
            };
            
            if (code >= 4000 && code <= 4999) {
                return { name: 'APP_CUSTOM', description: 'åº”ç”¨è‡ªå®šä¹‰å…³é—­ç ' };
            }
            
            return closeCodes[code] || { name: 'UNKNOWN', description: 'æœªçŸ¥å…³é—­ç ' };
        }

        function disconnectWebSocket() {
            // åœæ­¢å¿ƒè·³
            stopHeartbeat();
            
            if (wsConnection) {
                wsConnection.close();
                wsConnection = null;
                
                // æ›´æ–°æŒ‰é’®çŠ¶æ€
                const connectBtn = document.getElementById('wsConnectBtn');
                const disconnectBtn = document.getElementById('wsDisconnectBtn');
                connectBtn.disabled = false;
                disconnectBtn.disabled = true;
            }
        }

        function sendWebSocketMessage() {
            const message = document.getElementById('wsMessage').value;

            if (!message) {
                alert('è¯·è¾“å…¥æ¶ˆæ¯å†…å®¹');
                return;
            }

            if (!wsConnection || wsConnection.readyState !== WebSocket.OPEN) {
                alert('WebSocketæœªè¿æ¥');
                return;
            }

            try {
                wsConnection.send(message);
                logWSEvent('send', 'ğŸ“¤ å‘é€æ¶ˆæ¯: ' + message);
                document.getElementById('wsMessage').value = '';
            } catch (error) {
                logWSEvent('error', 'âŒ å‘é€å¤±è´¥: ' + error.message);
            }
        }

        function logWSEvent(type, message) {
            const log = document.getElementById('wsLog');
            
            // æ¸…é™¤ç©ºçŠ¶æ€
            if (log.querySelector('.empty-state')) {
                log.innerHTML = '';
            }

            const time = new Date().toLocaleTimeString();
            const item = document.createElement('div');
            item.className = 'event-item';
            item.innerHTML = `<span class="event-time">[${time}]</span><span class="event-type">[${type.toUpperCase()}]</span><span class="event-data">${message}</span>`;
            log.appendChild(item);
            log.scrollTop = log.scrollHeight;
        }

        function clearWSLog() {
            const log = document.getElementById('wsLog');
            log.innerHTML = '<div class="empty-state"><div style="font-size: 40px; margin-bottom: 10px;">ğŸ’¬</div><p>æ—¥å¿—å·²æ¸…ç©º</p></div>';
        }

        // cURL å¯¼å…¥å¯¼å‡ºåŠŸèƒ½
        function toggleCurlImport() {
            const section = document.getElementById('curlImportSection');
            section.style.display = section.style.display === 'none' ? 'block' : 'none';
            if (section.style.display === 'block') {
                document.getElementById('curlInput').focus();
            }
        }

        function copyCurl() {
            const method = document.getElementById('httpMethod').value;
            const url = document.getElementById('httpUrl').value;
            const body = document.getElementById('httpBody').value;

            if (!url) {
                alert('è¯·å…ˆè¾“å…¥URL');
                return;
            }

            // æ„å»ºcurlå‘½ä»¤
            let curlCommand = `curl -X ${method} '${url}'`;

            // æ·»åŠ è¯·æ±‚å¤´
            const headerRows = document.querySelectorAll('#httpHeaders .header-row');
            headerRows.forEach(row => {
                const inputs = row.querySelectorAll('input');
                const name = inputs[0].value.trim();
                const value = inputs[1].value.trim();
                if (name) {
                    curlCommand += ` \\\n  -H '${name}: ${value}'`;
                }
            });

            // æ·»åŠ è¯·æ±‚ä½“
            if (body && ['POST', 'PUT', 'PATCH'].includes(method)) {
                const escapedBody = body.replace(/'/g, "'\\''");
                curlCommand += ` \\\n  -d '${escapedBody}'`;
            }

            // å¤åˆ¶åˆ°å‰ªè´´æ¿
            navigator.clipboard.writeText(curlCommand).then(() => {
                // æ˜¾ç¤ºå¤åˆ¶æˆåŠŸæç¤º
                const btn = event.target;
                const originalText = btn.textContent;
                btn.textContent = 'âœ… å·²å¤åˆ¶';
                btn.style.background = '#4caf50';
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.background = '';
                }, 2000);
            }).catch(err => {
                alert('å¤åˆ¶å¤±è´¥ï¼š' + err.message + '\n\nå‘½ä»¤å·²ç”Ÿæˆï¼š\n' + curlCommand);
            });
        }

        function previewCurl() {
            const curlInput = document.getElementById('curlInput').value.trim();

            if (!curlInput) {
                alert('è¯·å…ˆç²˜è´´cURLå‘½ä»¤');
                return;
            }

            try {
                const parsed = parseCurlCommand(curlInput);
                
                let preview = 'ğŸ” cURL è§£æé¢„è§ˆ\n';
                preview += '='.repeat(50) + '\n\n';
                preview += `ğŸ“ URL:\n${parsed.url || 'âŒ æœªè¯†åˆ«'}\n\n`;
                preview += `ğŸ“® æ–¹æ³•:\n${parsed.method}\n\n`;
                
                if (parsed.headers.length > 0) {
                    preview += `ğŸ“‹ è¯·æ±‚å¤´ (${parsed.headers.length}):\n`;
                    parsed.headers.forEach(h => {
                        preview += `  â€¢ ${h.name}: ${h.value}\n`;
                    });
                    preview += '\n';
                } else {
                    preview += 'ğŸ“‹ è¯·æ±‚å¤´: æ— \n\n';
                }
                
                if (parsed.body) {
                    preview += `ğŸ“ è¯·æ±‚ä½“ (${parsed.body.length} å­—ç¬¦):\n`;
                    preview += `${parsed.body}\n\n`;
                } else {
                    preview += 'ğŸ“ è¯·æ±‚ä½“: æ— \n\n';
                }

                preview += `ğŸ’¡ Bodyç±»å‹: ${parsed.bodyType}\n`;
                preview += '='.repeat(50);

                document.getElementById('curlPreviewContent').textContent = preview;
                document.getElementById('curlPreview').style.display = 'block';

            } catch (error) {
                alert('âŒ è§£æå¤±è´¥ï¼š' + error.message);
                console.error('é¢„è§ˆé”™è¯¯ï¼š', error);
            }
        }

        function parseCurlCommand(curlInput) {
            // æ¸…ç†å‘½ä»¤
            let curl = curlInput.replace(/\\\s*\n\s*/g, ' ').trim();

            const result = {
                url: '',
                method: 'GET',
                headers: [],
                body: '',
                bodyType: 'json'
            };

            // æå–URL
            const urlPatterns = [
                /curl\s+(?:-X\s+\w+\s+)?['"]([^'"]+)['"]/,
                /curl\s+(?:-X\s+\w+\s+)?(\S+)/,
                /curl\s+['"]([^'"]+)['"]/,
                /curl\s+(\S+)/,
            ];
            
            for (const pattern of urlPatterns) {
                const match = curl.match(pattern);
                if (match && match[1] && !match[1].startsWith('-')) {
                    result.url = match[1];
                    break;
                }
            }

            // æå–æ–¹æ³•
            const methodMatch = curl.match(/-X\s+(\w+)/i) || curl.match(/--request\s+(\w+)/i);
            if (methodMatch) {
                result.method = methodMatch[1].toUpperCase();
            } else if (curl.includes('-d ') || curl.includes('--data')) {
                result.method = 'POST';
            }

            // æå–è¯·æ±‚å¤´ - æ”¹è¿›çš„è§£æé€»è¾‘
            const headerRegex = /(-H|--header)\s+/g;
            let match;
            
            while ((match = headerRegex.exec(curl)) !== null) {
                const startIndex = match.index + match[0].length;
                const remaining = curl.substring(startIndex);
                
                let headerContent = '';
                
                // æ£€æŸ¥æ˜¯å¦ä»¥å¼•å·å¼€å§‹
                if (remaining[0] === '"' || remaining[0] === "'") {
                    const quoteChar = remaining[0];
                    let endIndex = 1;
                    let escaped = false;
                    
                    // æŸ¥æ‰¾åŒ¹é…çš„ç»“æŸå¼•å·ï¼ˆè€ƒè™‘è½¬ä¹‰ï¼‰
                    while (endIndex < remaining.length) {
                        if (escaped) {
                            escaped = false;
                        } else if (remaining[endIndex] === '\\') {
                            escaped = true;
                        } else if (remaining[endIndex] === quoteChar) {
                            break;
                        }
                        endIndex++;
                    }
                    
                    headerContent = remaining.substring(1, endIndex);
                } else {
                    // ä¸å¸¦å¼•å·ï¼Œæå–åˆ°ç©ºæ ¼æˆ–è¡Œå°¾
                    const headerMatch = remaining.match(/^(\S+)/);
                    if (headerMatch) {
                        headerContent = headerMatch[1];
                    }
                }
                
                // è§£æ header name å’Œ value
                if (headerContent) {
                    const colonIndex = headerContent.indexOf(':');
                    if (colonIndex > 0) {
                        const name = headerContent.substring(0, colonIndex).trim();
                        const value = headerContent.substring(colonIndex + 1).trim();
                        result.headers.push({ name, value });
                    }
                }
            }

            // æå–è¯·æ±‚ä½“ - æ”¹è¿›çš„è§£æé€»è¾‘
            let bodyData = '';
            
            // å°è¯•åŒ¹é… -d æˆ– --data æˆ– --data-raw ç­‰å‚æ•°
            const dataParamMatch = curl.match(/(-d|--data|--data-raw|--data-binary|--data-urlencode)\s+/);
            
            if (dataParamMatch) {
                const startIndex = dataParamMatch.index + dataParamMatch[0].length;
                const remaining = curl.substring(startIndex);
                
                // æ£€æŸ¥æ˜¯å¦ä»¥å¼•å·å¼€å§‹
                if (remaining[0] === '"' || remaining[0] === "'") {
                    const quoteChar = remaining[0];
                    let endIndex = 1;
                    let escaped = false;
                    
                    // æŸ¥æ‰¾åŒ¹é…çš„ç»“æŸå¼•å·ï¼ˆè€ƒè™‘è½¬ä¹‰ï¼‰
                    while (endIndex < remaining.length) {
                        if (escaped) {
                            escaped = false;
                        } else if (remaining[endIndex] === '\\') {
                            escaped = true;
                        } else if (remaining[endIndex] === quoteChar) {
                            break;
                        }
                        endIndex++;
                    }
                    
                    bodyData = remaining.substring(1, endIndex);
                } else {
                    // ä¸å¸¦å¼•å·ï¼Œæå–åˆ°ç©ºæ ¼æˆ–è¡Œå°¾
                    const match = remaining.match(/^(\S+)/);
                    if (match) {
                        bodyData = match[1];
                    }
                }
                
                // å¤„ç†è½¬ä¹‰å­—ç¬¦
                if (bodyData) {
                    result.body = bodyData.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/\\\\/g, '\\');
                }
            }

            if (result.body) {
                try {
                    JSON.parse(result.body);
                    result.bodyType = 'json';
                } catch (e) {
                    if (result.body.includes('=') && result.body.includes('&')) {
                        result.bodyType = 'form';
                    } else {
                        result.bodyType = 'text';
                    }
                }
            }

            return result;
        }

        function importCurl() {
            const curlInput = document.getElementById('curlInput').value.trim();

            if (!curlInput) {
                alert('è¯·ç²˜è´´cURLå‘½ä»¤');
                return;
            }

            try {
                const parsed = parseCurlCommand(curlInput);

                // å¡«å……URL
                if (parsed.url) {
                    document.getElementById('httpUrl').value = parsed.url;
                } else {
                    alert('âš ï¸ æ— æ³•æå–URLï¼Œè¯·æ£€æŸ¥cURLå‘½ä»¤æ ¼å¼');
                    return;
                }

                // å¡«å……æ–¹æ³•
                document.getElementById('httpMethod').value = parsed.method;

                // å¡«å……è¯·æ±‚å¤´
                const headerContainer = document.getElementById('httpHeaders');
                if (parsed.headers.length > 0) {
                    headerContainer.innerHTML = '';
                    parsed.headers.forEach(header => {
                        const row = document.createElement('div');
                        row.className = 'header-row';
                        row.innerHTML = `
                            <input type="text" placeholder="Header Name" value="${escapeHtml(header.name)}">
                            <input type="text" placeholder="Header Value" value="${escapeHtml(header.value)}">
                            <button class="button-remove" onclick="removeHeader(this)">åˆ é™¤</button>
                        `;
                        headerContainer.appendChild(row);
                    });
                } else {
                    // å¦‚æœæ²¡æœ‰è¯·æ±‚å¤´ï¼Œä¿ç•™é»˜è®¤çš„
                    headerContainer.innerHTML = `
                        <div class="header-row">
                            <input type="text" placeholder="Header Name" value="Content-Type">
                            <input type="text" placeholder="Header Value" value="application/json">
                            <button class="button-remove" onclick="removeHeader(this)">åˆ é™¤</button>
                        </div>
                    `;
                }

                // å¡«å……è¯·æ±‚ä½“
                if (parsed.body) {
                    // å°è¯•æ ¼å¼åŒ–JSON
                    let bodyData = parsed.body;
                    try {
                        const jsonParsed = JSON.parse(bodyData);
                        bodyData = JSON.stringify(jsonParsed, null, 2);
                    } catch (e) {
                        // ä¸æ˜¯JSONï¼Œä¿æŒåŸæ ·
                    }
                    document.getElementById('httpBody').value = bodyData;
                    document.getElementById('bodyType').value = parsed.bodyType;
                } else {
                    document.getElementById('httpBody').value = '';
                }

                updateBodyPlaceholder();

                // å…³é—­å¯¼å…¥é¢æ¿
                toggleCurlImport();
                document.getElementById('curlInput').value = '';
                document.getElementById('curlPreview').style.display = 'none';

                // æ˜¾ç¤ºè¯¦ç»†çš„å¯¼å…¥ç»“æœ
                let importDetails = 'âœ… cURLå‘½ä»¤å¯¼å…¥æˆåŠŸï¼\n\nå¯¼å…¥å†…å®¹ï¼š\n';
                importDetails += `ğŸ“ URL: ${parsed.url}\n`;
                importDetails += `ğŸ“® æ–¹æ³•: ${parsed.method}\n`;
                importDetails += `ğŸ“‹ è¯·æ±‚å¤´: ${parsed.headers.length} ä¸ª\n`;
                importDetails += `ğŸ“ è¯·æ±‚ä½“: ${parsed.body ? parsed.body.length + ' å­—ç¬¦' : 'æ— '}\n`;
                
                alert(importDetails);

            } catch (error) {
                alert('âŒ è§£æcURLå‘½ä»¤å¤±è´¥ï¼š' + error.message + '\n\nè¯·ç¡®ä¿cURLå‘½ä»¤æ ¼å¼æ­£ç¡®ã€‚\n\næç¤ºï¼š\n1. å…ˆç‚¹å‡»"ğŸ” é¢„è§ˆè§£æç»“æœ"æ£€æŸ¥è§£ææ˜¯å¦æ­£ç¡®\n2. æ”¯æŒæ ¼å¼ï¼šcurl -X POST "url" -H "header" -d "data"');
                console.error('cURLè§£æé”™è¯¯ï¼š', error);
                console.log('åŸå§‹å‘½ä»¤ï¼š', curlInput);
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // å¤åˆ¶å“åº”è¯¦æƒ…
        function copyResponseDetails() {
            const content = document.getElementById('httpResponseContent').textContent;
            const status = document.getElementById('httpStatus').textContent;
            const time = document.getElementById('httpTime').textContent;
            const size = document.getElementById('httpSize').textContent;

            const fullLog = `APIè°ƒè¯•æ—¥å¿—
${'='.repeat(70)}
çŠ¶æ€ç : ${status}
å“åº”æ—¶é—´: ${time}
å“åº”å¤§å°: ${size}
ç”Ÿæˆæ—¶é—´: ${new Date().toLocaleString()}

${content}
${'='.repeat(70)}`;

            navigator.clipboard.writeText(fullLog).then(() => {
                const btn = event.target;
                const originalText = btn.textContent;
                btn.textContent = 'âœ… å·²å¤åˆ¶';
                btn.style.background = '#4caf50';
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.background = '';
                }, 2000);
            }).catch(err => {
                alert('å¤åˆ¶å¤±è´¥ï¼š' + err.message);
            });
        }

        // ä¸€é”®æ¸…ç©ºHTTPè¡¨å•
        function clearHttpForm() {
            if (!confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰å­—æ®µå—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚')) {
                return;
            }

            // æ¸…ç©ºURLå’Œé‡ç½®æ–¹æ³•
            document.getElementById('httpUrl').value = '';
            document.getElementById('httpMethod').value = 'GET';

            // æ¸…ç©ºè¯·æ±‚ä½“å’Œé‡ç½®ç±»å‹
            document.getElementById('httpBody').value = '';
            document.getElementById('bodyType').value = 'json';
            updateBodyPlaceholder();

            // é‡ç½®è¯·æ±‚å¤´ï¼ˆä¿ç•™ä¸€ä¸ªé»˜è®¤çš„Content-Typeï¼‰
            const headerContainer = document.getElementById('httpHeaders');
            headerContainer.innerHTML = `
                <div class="header-row">
                    <input type="text" placeholder="Header Name" value="Content-Type">
                    <input type="text" placeholder="Header Value" value="application/json">
                    <button class="button-remove" onclick="removeHeader(this)">åˆ é™¤</button>
                </div>
            `;

            // éšè—å“åº”åŒºåŸŸ
            document.getElementById('httpResponse').style.display = 'none';

            // éšè—cURLå¯¼å…¥åŒºåŸŸ
            document.getElementById('curlImportSection').style.display = 'none';
            document.getElementById('curlInput').value = '';

            // æ˜¾ç¤ºæ¸…ç©ºæˆåŠŸæç¤º
            const statusEl = document.getElementById('httpStatus');
            const responseContent = document.getElementById('httpResponseContent');
            if (statusEl) {
                statusEl.textContent = 'å·²æ¸…ç©º';
                statusEl.className = 'response-meta-value';
            }
            if (responseContent) {
                responseContent.textContent = 'è¡¨å•å·²æ¸…ç©ºï¼Œå¯ä»¥å¼€å§‹æ–°çš„æµ‹è¯•';
            }

            // å¯é€‰ï¼šçŸ­æš‚æ˜¾ç¤ºæˆåŠŸåŠ¨ç”»
            const btn = event.target;
            const originalText = btn.textContent;
            btn.textContent = 'âœ… å·²æ¸…ç©º';
            btn.style.background = '#4caf50';
            setTimeout(() => {
                btn.textContent = originalText;
                btn.style.background = '';
            }, 1500);
        }

        // ä¸€é”®æ¸…ç©ºSSEè¡¨å•
        function clearSSEForm() {
            if (!confirm('ç¡®å®šè¦æ¸…ç©ºSSEé…ç½®å¹¶æ–­å¼€è¿æ¥å—ï¼Ÿ')) {
                return;
            }

            // æ–­å¼€è¿æ¥
            if (sseConnection) {
                sseConnection.close();
                sseConnection = null;
            }

            // æ¸…ç©ºURL
            document.getElementById('sseUrl').value = '';

            // é‡ç½®è¯·æ±‚å¤´
            const headerContainer = document.getElementById('sseHeaders');
            headerContainer.innerHTML = `
                <div class="header-row">
                    <input type="text" placeholder="Header Name" value="Authorization">
                    <input type="text" placeholder="Header Value" value="Bearer token">
                    <button class="button-remove" onclick="removeHeader(this)">åˆ é™¤</button>
                </div>
            `;

            // æ¸…ç©ºæ—¥å¿—
            const log = document.getElementById('sseLog');
            log.innerHTML = '<div class="empty-state"><div style="font-size: 40px; margin-bottom: 10px;">ğŸ“¡</div><p>è¡¨å•å·²æ¸…ç©ºï¼Œå¯ä»¥å¼€å§‹æ–°çš„æµ‹è¯•</p></div>';

            // é‡ç½®çŠ¶æ€
            document.getElementById('sseStatus').textContent = 'æœªè¿æ¥';
            document.getElementById('sseStatus').className = 'ws-status disconnected';

            // æ¸…ç©ºå¹¶éšè—curlå¯¼å…¥åŒºåŸŸ
            document.getElementById('sseCurlImportSection').style.display = 'none';
            document.getElementById('sseCurlInput').value = '';
            document.getElementById('sseCurlPreview').style.display = 'none';

            // é‡ç½®è°ƒè¯•æ¨¡å¼
            document.getElementById('sseDebugMode').checked = false;
            sseDebugMode = false;

            // é‡ç½®æŒ‰é’®çŠ¶æ€
            const connectBtn = document.getElementById('sseConnectBtn');
            const disconnectBtn = document.getElementById('sseDisconnectBtn');
            connectBtn.disabled = false;
            connectBtn.classList.remove('button-loading');
            connectBtn.textContent = 'è¿æ¥';
            disconnectBtn.disabled = true;

            // æ˜¾ç¤ºæ¸…ç©ºæˆåŠŸæç¤º
            const btn = event.target;
            const originalText = btn.textContent;
            btn.textContent = 'âœ… å·²æ¸…ç©º';
            btn.style.background = '#4caf50';
            setTimeout(() => {
                btn.textContent = originalText;
                btn.style.background = '';
            }, 1500);
        }

        // ä¸€é”®æ¸…ç©ºWebSocketè¡¨å•
        function clearWSForm() {
            if (!confirm('ç¡®å®šè¦æ¸…ç©ºWebSocketé…ç½®å¹¶æ–­å¼€è¿æ¥å—ï¼Ÿ')) {
                return;
            }

            // åœæ­¢å¿ƒè·³å¹¶æ–­å¼€è¿æ¥
            stopHeartbeat();
            if (wsConnection) {
                wsConnection.close();
                wsConnection = null;
            }

            // æ¸…ç©ºURLå’Œåè®®
            document.getElementById('wsUrl').value = '';
            document.getElementById('wsProtocols').value = '';

            // æ¸…ç©ºæ¶ˆæ¯è¾“å…¥æ¡†
            document.getElementById('wsMessage').value = '';

            // é‡ç½®è¯·æ±‚å¤´
            const headerContainer = document.getElementById('wsHeaders');
            headerContainer.innerHTML = `
                <div class="header-row">
                    <input type="text" placeholder="Header Name" value="Authorization">
                    <input type="text" placeholder="Header Value" value="Bearer token">
                    <button class="button-remove" onclick="removeHeader(this)">åˆ é™¤</button>
                </div>
            `;

            // é‡ç½®å¿ƒè·³è®¾ç½®
            document.getElementById('wsHeartbeatEnabled').checked = false;
            document.getElementById('wsHeartbeatInterval').value = '30';
            document.getElementById('wsHeartbeatMessage').value = 'ping';
            document.getElementById('wsHeartbeatTimeout').value = '10';
            document.getElementById('wsAutoReconnect').checked = false;

            // æ¸…ç©ºæ—¥å¿—
            const log = document.getElementById('wsLog');
            log.innerHTML = '<div class="empty-state"><div style="font-size: 40px; margin-bottom: 10px;">ğŸ’¬</div><p>è¡¨å•å·²æ¸…ç©ºï¼Œå¯ä»¥å¼€å§‹æ–°çš„æµ‹è¯•</p></div>';

            // é‡ç½®çŠ¶æ€
            document.getElementById('wsStatus').textContent = 'æœªè¿æ¥';
            document.getElementById('wsStatus').className = 'ws-status disconnected';

            // æ¸…ç©ºå¹¶éšè—curlå¯¼å…¥åŒºåŸŸ
            document.getElementById('wsCurlImportSection').style.display = 'none';
            document.getElementById('wsCurlInput').value = '';
            document.getElementById('wsCurlPreview').style.display = 'none';

            // é‡ç½®è°ƒè¯•æ¨¡å¼
            document.getElementById('wsDebugMode').checked = false;
            wsDebugMode = false;

            // é‡ç½®æŒ‰é’®çŠ¶æ€
            const connectBtn = document.getElementById('wsConnectBtn');
            const disconnectBtn = document.getElementById('wsDisconnectBtn');
            connectBtn.disabled = false;
            connectBtn.classList.remove('button-loading');
            connectBtn.textContent = 'è¿æ¥';
            disconnectBtn.disabled = true;

            // æ˜¾ç¤ºæ¸…ç©ºæˆåŠŸæç¤º
            const btn = event.target;
            const originalText = btn.textContent;
            btn.textContent = 'âœ… å·²æ¸…ç©º';
            btn.style.background = '#4caf50';
            setTimeout(() => {
                btn.textContent = originalText;
                btn.style.background = '';
            }, 1500);
        }

        // é¡µé¢å¸è½½æ—¶æ¸…ç†è¿æ¥
        window.addEventListener('beforeunload', function() {
            if (sseConnection) sseConnection.close();
            if (wsConnection) wsConnection.close();
        });
    </script>
</body>
</html>
